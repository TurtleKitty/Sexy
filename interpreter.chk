
(use srfi-1)
(use srfi-69)

(use numbers)
(use uuid)
(use vector-lib)


(define (map-pairs fn args)
    (let loop ((newlist '()) (pairs args))
        (if (atom? pairs)
            newlist
            (let ((key (first pairs)) (val (second pairs)))
                (loop (fn key val) (cddr pairs))))))

(define (thunk? fn)
    (define pinfo (procedure-information fn))
    (and
        (list? pinfo)
        (= 0 (sub1 (length pinfo)))))

(define (idk obj msg)
    (error (list "Message not understood!" obj msg)))

(define (sexy-send obj msg)
    (cond
        ((symbol? obj) (sexy-send-symbol obj msg))
        ((number? obj) (sexy-send-number obj msg))
        ((string? obj) (sexy-send-string obj msg))
        ((pair? obj) (sexy-send-pair obj msg))
        ((hash-table? obj) (sexy-send-obj obj msg))
        ((vector? obj) (sexy-send-vector obj msg))
        ((procedure? obj) (sexy-send-proc obj msg))
        ((port? obj) (sexy-send-port obj msg))
        (else (error (list "WTF kind of object was THAT?" obj msg)))))

(define (sexy-send-symbol obj msg)
    (case msg
        ((to-string) (symbol->string obj))
        (else
            (case obj
                ((true false) (sexy-send-bool obj msg))
                ((null) (sexy-send-null obj msg))
                (else
                    (case msg
                        ((type) 'symbol)
                        ((null?) 'false)
                        ((to-bool) 'true)
                        (else (idk obj msg))))))))

(define (sexy-send-bool obj msg)
    (case msg
        ((type) 'bool)
        ((null?) 'false)
        ((to-bool) obj)
        (else (idk obj msg))))

(define (sexy-send-null obj msg)
    (case msg
        ((to-bool) 'false)
        ((null?) 'true)
        ((type) 'null)
        (else (idk obj msg))))

(define (sexy-send-number obj msg)
    (case msg
        ((zero?) (if (eq? obj 0) 'true 'false))
        ((null?) 'false)
        ((to-bool) (if (eq? obj 0) 'false 'true))
        ((to-string) (number->string obj))
        (else
            (cond
                ((integer? obj) (sexy-send-int obj msg))
                ((rational? obj) (sexy-send-rat obj msg))
                ((real? obj) (sexy-send-real obj msg))
                (else (idk obj msg))))))

(define (sexy-send-int obj msg)
    (case msg
        ((type) 'int)
        ((times) 'niy)
        (else (idk obj msg))))
 
(define (sexy-send-rat obj msg)
    (case msg
        ((type) 'rational)
        ((numerator) (numerator obj))
        ((denominator) (denominator obj))
        ((floor) (floor obj))
        ((ceiling) (ceiling obj))
        ((round) (round obj))
        (else (idk obj msg))))

(define (sexy-send-real obj msg)
    (case msg
        ((type) 'real)
        ((floor) (floor obj))
        ((ceiling) (ceiling obj))
        ((round) (round obj))
        (else (idk obj msg))))

(define (sexy-send-string obj msg)
    (case msg
        ((type) 'string)
        ((null?) 'false)
        ((to-bool) (if (eq? (string-length obj) 0) 'false 'true))
        ((to-symbol) (string->symbol obj))
        ((to-number) (string->number obj))
        ((join) 'niy)
        ((split) 'niy)
        (else (idk obj msg))))

(define (sexy-send-pair obj msg)
    (case msg
        ((type) 'pair)
        ((null?) 'false)
        ((to-bool) (if (eq? (length obj) 0) 'false 'true))
        ((head) (car obj))
        ((tail) (cdr obj))
        ((len) (length obj))
        ((has?) (lambda (item) (member item obj)))
        ((map) (lambda (funk) (map funk obj)))
        ((filter) (lambda (funk) (filter funk obj)))
        ((fold) (lambda (init funk) (fold funk init obj)))
        ((foldr) (lambda (init funk) (fold-right funk init obj)))
        (else
            (if (number? msg)
                (list-ref obj msg)
                (idk obj msg)))))

(define (sexy-send-obj obj msg)
    (define fields (hash-table-ref obj 'fields))
    (define resends (hash-table-ref obj 'resends))
    (if (hash-table-exists? fields msg)
        (hash-table-ref fields msg)
        (if (hash-table-exists? resends msg)
            ((hash-table-ref resends msg)) ; exec the thunk
            (case msg
                ((type) 'obj)
                ((has?) (lambda (x) (hash-table-exists? fields x)))
                ((keys) (hash-table-keys fields))
                ((values) (hash-table-values fields))
                ((pairs) (hash-table->alist fields))
                ((clone) (hash-table-copy fields))
                ((set!) (lambda args (map-pairs (lambda (k v) (hash-table-set! fields k v)) args)))
                (else ((hash-table-ref obj 'default) msg))))))

(define (sexy-send-vector obj msg)
    (case msg
        ((type) 'vector)
        ((len) (vector-length obj))
        ((has?) (lambda (item) (member item obj)))
        ((map) (lambda (funk) (vector-map funk obj)))
        ((filter) (lambda (funk) (filter funk obj)))
        ((fold) (lambda (funk init) (fold funk init obj)))
        ((foldr) (lambda (funk init) (fold-right funk init obj)))
        (else
            (if (number? msg)
                (vector-ref obj msg)
                (idk obj msg)))))

(define (sexy-send-proc obj msg)
    (case msg
        ((type) 'fn)
        ((null?) 'false)
        ((to-bool) 'true)
        ((arity) 'niy)
        ((apply)
            (lambda (args)
                (define argo (sexy-options args))
                (obj argo)))
        (else (idk msg obj))))

(define (sexy-send-port obj msg) 
    (case msg
        ((type) 'port)
        ((null?) 'false)
        ((to-bool) 'true)
        ((read) (read obj))
        ((write) (write obj))
        ((print) (lambda (x) (display x) (newline)))
        (else (idk msg obj))))

(define (sexy-error form . args)
    (display form))

(define (sexy-options code)
    (let loop ((head (car code)) (tail (cdr code)) (options (sexy-object '() '() #f)) (argv '()))
        (define (go-on xs options args)
            (if (pair? xs)
                (loop (car xs) (cdr xs) options args)
                (sexy-object (list 'options options 'args (reverse args)) '() #f)))
        (if head
            (if (keyword? head)
                (begin
                    ((sexy-send options 'set!) (string->symbol (keyword->string head)) (car tail))
                    (go-on (cdr tail) options argv))
                (go-on tail options (cons head argv)))
            (go-on #f options argv))))

; (define (doterator)
;     (define (match? x)
;         (and (symbol? x)
;              (string-contains (symbol->string x) ".")))
;     (define (transform x)
;         (let* (
;             (str (symbol->string x))
;             (words (string-split str ".")))
;             (let loop ((this (string->symbol (car words))) (left (cdr words)))
;                 (if (eq? left '())
;                     this
;                     (loop (list this `(quote ,(string->symbol (car left)))) (cdr left))))))
;     (cons match? transform))


; (obj x 1 y 2 meh (lambda (x) (* x 10)) mah (lambda () 7) resend: ((obj2 'foo 'bar) (obj3 'baz)) auto: (mah) default: true)

(define (sexy-object args resends initial)
    (define this (make-hash-table))
    (define fields (make-hash-table))
    (define delegates (make-hash-table))
    (define (tset! k v)
            (hash-table-set! this k v))
    (define (fset! k v)
            (hash-table-set! fields k v))
    (define (rset! k v)
            (hash-table-set! delegates k v))
    (define (set-resend! rlist)
        (let ((delegate (car rlist)) (msgs (cdr rlist)))
            (map (lambda (msg) (rset! msg (lambda () (sexy-send delegate msg)))) msgs)))
    (map-pairs fset! args)
    (map set-resend! resends)
    (tset! 'fields fields)
    (tset! 'resends delegates)
    (tset! 'default (or initial (lambda (msg) 'null)))
    this)

(define (sexy-environment parent)
    (define env (sexy-object '() '() #f))
    (define (lookup name)
        (if (eq? name 'env)
            this
            (let ((val (sexy-send env name)))
                (if (eq? val 'null?)
                    (sexy-send parent name)
                    val))))
    (define (extend names vals)
        (define noob (sexy-environment env))
        ((sexy-send noob 'set!) (zip names vals)))
    (define (mutate! name val)
        ((lookup 'set!) name val))
    (define (set-null! name)
        (mutate! name 'null))
    (define (prep-defs seq)
        ; predefine all defs for mutual recursion
        (define (get-defs seq)
            (filter (lambda (x) (and (pair? x) (eq? (car x) 'def))) seq))
        (map set-null! (map cadr (get-defs seq))))
    (define (sexy-def code cont)
        (let ((name (car code)) (val (cadr code)))
            (set-null! name)
            (sexy-eval val (lambda (x) (mutate! name x) (cont x)))))
    (define (sexy-quote code cont)
        (cont (car code)))
    (define (sexy-if code cont)
        (let ((pred (car code)) (iftrue (cadr code)) (iffalse (caddr code)))
            (sexy-eval pred
                (lambda (b)
                    (if (eq? (sexy-send b 'to-bool) 'true)
                        (sexy-eval iftrue cont)
                        (sexy-eval iffalse cont))))))
    (define (sexy-seq code cont)
        (if (pair? code)
            (begin
                ; predefine all defs for mutual recursion
                (map set-null! (map cadr (filter (lambda (x) (and (pair? x) (eq? (car x) 'def))) (cdr code))))
                (let ((head (car code)) (tail (cdr code)))
                    (if (pair? tail)
                        (sexy-eval head
                            (lambda (h) (sexy-seq tail cont)))
                        (sexy-eval head cont))))
            (cont 'null)))
    (define (sexy-set! code cont)
        (let ((name (car code)) (val (cadr code)))
            (if (symbol? name)
                (if ((sexy-send env 'has?) name)
                    (sexy-eval val (lambda (v) (cont (mutate! name v))))
                    (error (list "Unknown name" name)))
                (error "set! wants a symbol!"))))
    (define (sexy-fn code cont)
        (let* ((formals (car code)) (bodies (cdr code)) (flen (length formals)))
            ; what do do about opts and rest?
            (cont
                (lambda (argo)
                    (define argv (sexy-send argo 'args))
                    (define options (sexy-send argo 'options))
                    (define fargs (take argv flen))
                    (define the-rest (drop argv flen))
(display fargs)
(display the-rest)
                    (define noob
                        ((sexy-send env 'extend)
                            (append formals '(opt rest))
                            (append fargs (list options the-rest))))
(display noob)
                    ((sexy-send noob 'eval) (cons 'seq bodies))))))
    (define (sexy-eval-list xs cont)
        (if (pair? xs)
            (sexy-eval (car xs)
                (lambda (v) (sexy-eval-list (cdr xs)
                    (lambda (t) (cont (cons v t))))))
            (sexy-eval xs cont)))
    (define (sexy-eval code cont)
        (if (atom? code)
            (if (symbol? code)
                (case code
                    ((true false null) (cont code))
                    (else
                        (if (sexy-keyword? code)
                            (cont code)
                            (cont (lookup code)))))
                (cont code))
            (let ((head (car code)) (tail (cdr code)))
                (case head
                    ((def) (sexy-def tail cont))
                    ((quote) (sexy-quote tail cont))
                    ((if) (sexy-if tail cont))
                    ((seq) (begin (prep-defs tail) (sexy-seq tail cont)))
                    ((set!) (sexy-set! tail cont))
                    ((fn) (sexy-fn tail cont))
                    (else (sexy-eval head
                        (lambda (f) (sexy-eval-list tail
                            (lambda (args) (cont ((sexy-send f 'apply) args)))))))))))
    (define this
        (sexy-object
            (list 'type 'env
                  'lookup lookup
                  'extend extend
                  'eval sexy-eval
                  'parent parent)
            (list (list env 'set! 'has? 'keys))
            #f))
    this)

(define (sexy-snarf fname)
    (lambda (argo)
        (apply fname (sexy-send argo 'args))))

(define (global-env)
    (define (nodef x)
        (error (list "Symbol not defined" x)))
    (define toplevel
        (sexy-object (list 'lookup nodef) '() #f))
    (define prelude
        (sexy-environment toplevel))
    (define preset! (sexy-send prelude 'set!))
    (define (fill-prelude fs)
        (define (setem! p)
            (preset! (car p) (cdr p)))
        (map setem! fs))
    (define snarfs
        (map (lambda (x) (cons x (sexy-snarf (eval x))))
            '(+ - * / list vector eq? equal?)))
    (define primitives
        (list
            (cons 'send (sexy-snarf sexy-send))
            (cons 'obj (lambda (argo)
                (define args (sexy-send argo 'args))
                (define opts (sexy-send argo 'options))
                (define rsend (sexy-send opts 'resend))
                (define default (sexy-send opts 'default))
                (if (eq? rsend 'null) (set! rsend '()) #f)
                (if (eq? default 'null) (set! default #f) #f)
                (sexy-object args rsend default)))))
    (fill-prelude (append snarfs primitives))
    prelude)


(define (repl)
    (define stdin (current-input-port))
    (define stdout (current-output-port))
    (define stderr (current-error-port))
    (define env (global-env))
    (define (loop)
        (display "(sexy) ")
        ((sexy-send env 'eval) (sexy-send stdin 'read) (lambda (v) ((sexy-send stdout 'print) v) (loop))))
    (loop))


