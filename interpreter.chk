
(use srfi-1)
(use srfi-69)

(use numbers)
(use uuid)

(define (map-pairs fn args)
    (let loop ((newlist '()) (pairs args))
        (if (null? pairs)
            newlist
            (let ((key (first pairs)) (val (second pairs)))
                (loop (fn key val) (cddr pairs))))))

(define (thunk? fn)
    (define pinfo (procedure-information fn))
    (and
        (list? pinfo)
        (= 0 (sub1 (length pinfo)))))

(define (idk obj msg)
    (error (list "Message not understood!" obj msg)))

(define (sexy-send obj msg)
    (cond
        ((symbol? obj) (sexy-send-symbol obj msg))
        ((number? obj) (sexy-send-number obj msg))
        ((string? obj) (sexy-send-string obj msg))
        ((pair? obj) (sexy-send-pair obj msg))
        ((vector? obj) (sexy-send-vector obj msg))
        ((hash-table? obj) (sexy-send-obj obj msg))
        ((procedure? obj) (sexy-send-proc obj msg))
        ((port? obj) (sexy-send-port obj msg))
        (else (error (list "WTF kind of object was THAT?" obj msg)))))

(define (sexy-send-symbol obj msg)
    (case msg
        ((to-string) (symbol->string obj))
        (else
            (case obj
                ((true false) (sexy-send-bool obj msg))
                ((null) (sexy-send-null obj msg))
                (else
                    (case msg
                        ((type) 'symbol)
                        ((null?) 'false)
                        ((to-bool) 'true)
                        (else (idk obj msg))))))

(define (sexy-send-bool obj msg)
    (case msg
        ((type) 'bool)
        ((null?) 'false)
        ((to-bool) obj)
        (else (idk obj msg))))

(define (sexy-send-null obj msg)
    (case msg
        ((to-bool) 'false)
        ((null?) 'true)
        ((type) 'null)
        ((id) 'null)
        (else (idk obj msg))))

(define (sexy-send-number obj msg)
    (case msg
        ((zero?) (if (eq? obj 0) 'true 'false))
        ((null?) 'false)
        ((to-bool) (if (eq? obj 0) 'false 'true))
        ((to-string) (number->string obj))
        ((id) obj)
        (else
            (cond
                ((integer? obj) (sexy-send-int obj msg))
                ((rational? obj) (sexy-send-rat obj msg))
                ((real? obj) (sexy-send-real obj msg))
                (else (idk obj msg))))))

(define (sexy-send-int obj msg)
    (case msg
        ((type) 'int)
        (else (idk obj msg))))
 
(define (sexy-send-rat obj msg)
    (case msg
        ((type) 'rational)
        ((numerator) (numerator obj))
        ((denominator) (denominator obj))
        ((floor) (floor obj))
        ((ceiling) (ceiling obj))
        ((round) (round obj))
        (else (idk obj msg))))

(define (sexy-send-real obj msg)
    (case msg
        ((type) 'real)
        ((floor) (floor obj))
        ((ceiling) (ceiling obj))
        ((round) (round obj))
        (else (idk obj msg))))

(define (sexy-send-string obj msg)
    (case msg
        ((to-symbol) (string->symbol obj))
        ((to-number) (string->number obj))
        (else (idk obj msg))))

(define (sexy-send-pair obj msg)
)

(define (sexy-send-vector obj msg)
)

(define (sexy-send-obj obj msg)
)

(define (sexy-send-proc obj msg)
)

(define (sexy-send-port obj msg)
)

(define (sexy-error form . args)
    (display form))


; (obj x 1 y 2 meh (lambda (x) (* x 10)) mah (lambda () 7) resend: ((obj2 'foo 'bar) (obj3 'baz)) auto: (mah) default: true)

(define (sexy-object args resends initial)
    (define this (make-hash-table))
    (define vtable (make-hash-table))
    (define meta (make-hash-table))
    (define (vset! k v)
            (hash-table-set! vtable k v))
    (define (mset! k v)
            (hash-table-set! meta k v))
    (define (set-resend! rlist)
        (let ((delegate (car rlist)) (msgs (cdr rlist)))
            (map (lambda (msg) (mset! msg (lambda () (sexy-send delegate msg)) msgs)))))
    (define (set-default! k v)
        (if ((and (not (hash-table-exists? vtable k)) (not (hash-table-exists? meta k))))
            (mset! k v)))
    (define (has? x) (hash-table-exists? vtable x))
    (define (keys) (hash-table-keys vtable))
    (define (objvalues) (hash-table-values vtable))
    (define (pairs) (map sexy-pair (hash-table->alist vtable)))     ; FIXME
    (define (clone) (alist->hash-table (hash-table->alist vtable))) ; FIXME
    (define (objset! . kvs) (map-pairs vset! kvs))
    (map-pairs vset! args)
    (map set-resend! resends)
    (map-pairs set-default!
        (list
                'id     (uuid-v4)
                'type   'obj
                'has    has?
                'keys   keys
                'values objvalues
                'pairs  pairs
                'clone  clone
                'set!   objset!
                'null?  (sexy-bool 'false)
            ))
    vtable)

(define (sexy-function args body env)
    ())

(define (sexy-pair x y)
    (cons x y))

(define (sexy-list . this)
    (define (head) (car this))
    (define (tail) (cdr this))
    (define (len) (length this))
    (define (has? x) (member x this))
    (define (mymap fn) (map fn this))
    (sexy-object
        'type 'list
        'head head
        'tail tail
        'len len
        'has? has?
        'map mymap
        'clone
        'scheme
))

(define (sexy-environment parent)
    (define env (sexy-object () () (lambda () (error "Symbol not defined"))))
    (define self (sexy-object ('lookup lookup 'extend extend 'eval sexy-eval) ((env 'set 'keys))))
    (define (lookup name)
        (sexy-send env name))
    (define (extend names vals)
        (define noob (sexy-environment env))
        (map (lambda (x y) ((sexy-send noob 'set!) x y)) names vals))
    (define (mutate! name val)
        ((lookup 'set!) name val))
    (define (set-null! name)
        (mutate! name 'null))
    (define (sexy-def code cont)
        (let ((name (cadr code)) (val (caddr code)))
            (set-null! name)
            (sexy-eval val (lambda (x) (mutate! name x) (cont x)))))
    (define (sexy-quote code cont)
        (cont code))
    (define (sexy-if code cont)
        (let ((pred (cadr code)) (iftrue (caddr code)) (iffalse (cadddr code)))
            (sexy-eval pred
                (lambda (b)
                    (if (eq? (sexy-send b 'as-bool) 'true)
                        (sexy-eval iftrue cont)
                        (sexy-eval iffalse cont))))))
    (define (sexy-seq code cont)
        (if (pair? (cdr code))
            (begin
                (map set-null! (map cadr (filter (lambda (x) (and (pair? x) (eq? (car x) 'def)))))) ; predefine all defs for mutual recursion
                (let loop ((head (cadr code)) (tail (caddr code)))
                    (if (pair? tail)
                        (sexy-eval head
                            (lambda (h) (loop tail cont)))
                        (sexy-eval head cont))))
            (cont 'null)))
    (define (sexy-set! code cont)
        (if (symbol? code)
            (cont (mutate!))
            (error "Symbol not defined!")))
    (define (sexy-fn code cont)
        cont)
    (define (sexy-eval-list xs cont)
        (if (pair? xs)
            (sexy-eval (car xs)
                (lambda (v) (sexy-eval-list (cdr xs)
                    (lambda (t) (cont (cons v t))))))
            (sexy-eval xs cont)))
    (define (sexy-eval code cont)
        (if (atom? code)
            (if (symbol? code)
                (cont (lookup code))
                'eval-atom)
            (let ((head (car code)) (tail (cdr code)))
                (case head
                    ((def) 'def-cont)
                    ((quote) 'quote-cont)
                    ((if) 'if-cont)
                    ((seq) 'seq-cont)
                    ((set!) 'set!-cont)
                    ((fn) 'fn-cont)
                    (else 'apply-cont))))))


; testies

(define kewl (sexy-object 'foo 1 'bar 2 'baz (lambda (x) (* x x))))
(define kewler (sexy-object 'type 'foonballardy 'value 10))
(define kewllist (sexy-list 1 2 3 4 5 7 'beta))

(map
    (lambda (x) (display x) (newline))
    (list
        (sexy-send kewl 'foo)
        ((sexy-send kewl 'keys))
        ((sexy-send kewl 'baz) 10)
        (sexy-send kewler 'type)
        (sexy-send kewler 'value)
        ((sexy-send kewllist 'len))
        ((sexy-send kewllist 'head))
        ((sexy-send kewllist 'tail))
        ((sexy-send kewllist 'map) (lambda (x) (if (number? x) (* x 10) x))) 
))



