
(use srfi-1)
(use srfi-69)

(use numbers)
(use uuid)
(use vector-lib)


(define (map-pairs fn args)
    (let loop ((newlist '()) (pairs args))
        (if (null? pairs)
            newlist
            (let ((key (first pairs)) (val (second pairs)))
                (loop (fn key val) (cddr pairs))))))

(define (thunk? fn)
    (define pinfo (procedure-information fn))
    (and
        (list? pinfo)
        (= 0 (sub1 (length pinfo)))))

(define (idk obj msg)
    (error (list "Message not understood!" obj msg)))

(define (sexy-send obj msg)
    (cond
        ((symbol? obj) (sexy-send-symbol obj msg))
        ((number? obj) (sexy-send-number obj msg))
        ((string? obj) (sexy-send-string obj msg))
        ((pair? obj) (sexy-send-pair obj msg))
        ((hash-table? obj) (sexy-send-obj obj msg))
        ((vector? obj) (sexy-send-vector obj msg))
        ((procedure? obj) (sexy-send-proc obj msg))
        ((port? obj) (sexy-send-port obj msg))
        (else (error (list "WTF kind of object was THAT?" obj msg)))))

(define (sexy-send-symbol obj msg)
    (case msg
        ((to-string) (symbol->string obj))
        (else
            (case obj
                ((true false) (sexy-send-bool obj msg))
                ((null) (sexy-send-null obj msg))
                (else
                    (case msg
                        ((type) 'symbol)
                        ((null?) 'false)
                        ((to-bool) 'true)
                        (else (idk obj msg))))))))

(define (sexy-send-bool obj msg)
    (case msg
        ((type) 'bool)
        ((null?) 'false)
        ((to-bool) obj)
        (else (idk obj msg))))

(define (sexy-send-null obj msg)
    (case msg
        ((to-bool) 'false)
        ((null?) 'true)
        ((type) 'null)
        ((id) 'null)
        (else (idk obj msg))))

(define (sexy-send-number obj msg)
    (case msg
        ((zero?) (if (eq? obj 0) 'true 'false))
        ((null?) 'false)
        ((to-bool) (if (eq? obj 0) 'false 'true))
        ((to-string) (number->string obj))
        ((id) obj)
        (else
            (cond
                ((integer? obj) (sexy-send-int obj msg))
                ((rational? obj) (sexy-send-rat obj msg))
                ((real? obj) (sexy-send-real obj msg))
                (else (idk obj msg))))))

(define (sexy-send-int obj msg)
    (case msg
        ((type) 'int)
        ((times) 'niy)
        (else (idk obj msg))))
 
(define (sexy-send-rat obj msg)
    (case msg
        ((type) 'rational)
        ((numerator) (numerator obj))
        ((denominator) (denominator obj))
        ((floor) (floor obj))
        ((ceiling) (ceiling obj))
        ((round) (round obj))
        (else (idk obj msg))))

(define (sexy-send-real obj msg)
    (case msg
        ((type) 'real)
        ((floor) (floor obj))
        ((ceiling) (ceiling obj))
        ((round) (round obj))
        (else (idk obj msg))))

(define (sexy-send-string obj msg)
    (case msg
        ((type) 'string)
        ((null?) 'false)
        ((to-bool) (if (eq? (string-length obj) 0) 'false 'true))
        ((to-symbol) (string->symbol obj))
        ((to-number) (string->number obj))
        ((join) 'niy)
        ((split) 'niy)
        (else (idk obj msg))))

(define (sexy-send-pair obj msg)
    (case msg
        ((type) 'pair)
        ((null?) 'false)
        ((to-bool) (if (eq? (length obj) 0) 'false 'true))
        ((head) (car obj))
        ((tail) (cdr obj))
        ((len) (length obj))
        ((has?) (lambda (item) (member item obj)))
        ((map) (lambda (funk) (map funk obj)))
        ((filter) (lambda (funk) (filter funk obj)))
        ((fold) (lambda (funk init) (fold funk init obj)))
        ((foldr) (lambda (funk init) (fold-right funk init obj)))
        (else
            (if (number? msg)
                (list-ref obj msg)
                (idk obj msg)))))

(define (sexy-send-obj obj msg)
    (if (hash-table-exists? obj msg)
        (hash-table-ref obj msg)
        (case msg
            ((type) 'obj)
            ((has?) (lambda (x) (hash-table-exists? obj x)))
            ((keys) (hash-table-keys obj))
            ((values) (hash-table-values obj))
            ((pairs) (hash-table->alist obj))
            ((clone) (hash-table-copy obj))
            ((set!) (lambda args (map-pairs (lambda (k v) (hash-table-set! obj k v)) args)))
            (else ((hash-table-ref obj 'default) msg)))))

(define (sexy-send-vector obj msg)
    (case msg
        ((type) 'vector)
        ((len) (vector-length obj))
        ((has?) (lambda (item) (member item obj)))
        ((map) (lambda (funk) (vector-map funk obj)))
        ((filter) (lambda (funk) (filter funk obj)))
        ((fold) (lambda (funk init) (fold funk init obj)))
        ((foldr) (lambda (funk init) (fold-right funk init obj)))
        (else
            (if (number? msg)
                (vector-ref obj msg)
                (idk obj msg)))))

(define (sexy-send-proc obj msg)
    (case msg
        ((type) 'fn)
        ((null?) 'false)
        ((to-bool) 'true)
        ((arity) 'niy)
        ((apply) 'niy)
        (else (idk msg obj))))

(define (sexy-send-port obj msg) 'null)

(define (sexy-error form . args)
    (display form))


; (obj x 1 y 2 meh (lambda (x) (* x 10)) mah (lambda () 7) resend: ((obj2 'foo 'bar) (obj3 'baz)) auto: (mah) default: true)

(define (sexy-object args resends initial)
    (define this (make-hash-table))
    (define (vset! k v)
            (hash-table-set! this k v))
    (define (set-resend! rlist)
        (let ((delegate (car rlist)) (msgs (cdr rlist)))
            (map (lambda (msg) (vset! msg (lambda () (sexy-send delegate msg)))) msgs)))
    (vset! 'default (or initial (lambda (x) 'null)))
    (map-pairs vset! args)
    (map set-resend! resends)
    this)

(define (sexy-environment parent)
    (define env (sexy-object '() '() #f))
    (define (lookup name)
        (if (eq? name 'env)
            this
            (let ((val (sexy-send env name)))
                (if (sexy-send val 'null?)
                    (sexy-send parent name)
                    val))))
    (define (extend names vals)
        (define noob (sexy-environment env))
        ((sexy-send noob 'set!) (zip names vals)))
    (define (mutate! name val)
        ((lookup 'set!) name val))
    (define (set-null! name)
        (mutate! name 'null))
    (define (prep-defs seq)
        ; predefine all defs for mutual recursion
        (define (get-defs seq)
            (filter (lambda (x) (and (pair? x) (eq? (car x) 'def))) seq))
        (map set-null! (map cadr (get-defs seq))))
    (define (sexy-def code cont)
        (let ((name (car code)) (val (cadr code)))
            (set-null! name)
            (sexy-eval val (lambda (x) (mutate! name x) (cont x)))))
    (define (sexy-quote code cont)
        (cont code))
    (define (sexy-if code cont)
        (let ((pred (car code)) (iftrue (cadr code)) (iffalse (caddr code)))
            (sexy-eval pred
                (lambda (b)
                    (if (eq? (sexy-send b 'to-bool) 'true)
                        (sexy-eval iftrue cont)
                        (sexy-eval iffalse cont))))))
    (define (sexy-seq code cont)
        (if (pair? code)
            (begin
                ; predefine all defs for mutual recursion
                (map set-null! (map cadr (filter (lambda (x) (and (pair? x) (eq? (car x) 'def))) (cdr code))))
                (let ((head (car code)) (tail (cdr code)))
                    (if (pair? tail)
                        (sexy-eval head
                            (lambda (h) (sexy-seq tail cont)))
                        (sexy-eval head cont))))
            (cont 'null)))
    (define (sexy-set! code cont)
        (let ((name (car code)) (val (cadr code)))
            (if (symbol? name)
                (if ((sexy-send env 'has?) name)
                    (sexy-eval val (lambda (v) (cont (mutate! name v))))
                    (error (list "Unknown name" name)))
                (error "set! wants a symbol!"))))
    (define (sexy-fn code cont)
        (let ((args (car code)) (bodies (cdr code)))
            ; what do do about opts and rest?
            (cont 
                (lambda (vals opt rest)
                    (let ((noob ((sexy-send env 'extend) (cons 'opt (cons 'rest args)) (cons opt (cons rest vals)))))
                        ((sexy-send noob 'eval) (cons 'seq bodies)))))))
    (define (sexy-eval-list xs cont)
        (if (pair? xs)
            (sexy-eval (car xs)
                (lambda (v) (sexy-eval-list (cdr xs)
                    (lambda (t) (cont (cons v t))))))
            (sexy-eval xs cont)))
    (define (sexy-eval code cont)
        (if (atom? code)
            (if (symbol? code)
                (case code
                    ((true false null) (cont code))
                    (else (cont (lookup code))))
                (cont code))
            (let ((head (car code)) (tail (cdr code)))
                (case head
                    ((def) (sexy-def tail cont))
                    ((quote) (sexy-quote tail cont))
                    ((if) (sexy-if tail cont))
                    ((seq) (begin (prep-defs tail) (sexy-seq tail cont)))
                    ((set!) (sexy-set! tail cont))
                    ((fn) (sexy-fn tail cont))
                    (else (sexy-eval head
                        (lambda (f) (sexy-eval-list tail
                            (lambda (args) (cont ((sexy-send f 'apply) args)))))))))))
    (define this
        (sexy-object
            (list 'lookup lookup
                  'extend extend
                  'eval sexy-eval
                  'parent parent)
            (list (list env 'set! 'has? 'keys))
            #f))
    this)

(define (repl)
    (define stdin 'null)
    (define stdout 'null)
    (define stderr 'null)
    (define (nodef x)
        (error (list "Symbol not defined" x)))
    (define toplevel
        (sexy-object (list 'lookup nodef) '() #f))
    (define prelude
        (sexy-environment toplevel))
    ;((sexy-send prelude 'set!)  )
    (display "(sexy) ")
    ((sexy-send prelude 'eval) (read) (lambda (v) (display v) (newline) (repl))))


