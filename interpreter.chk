
(use srfi-1)
(use srfi-69)
(use uuid)

(define (map-pairs fn args)
    (let loop ((newlist '()) (pairs args))
        (if (null? pairs)
            newlist
            (let ((key (first pairs)) (val (second pairs)))
                (loop (fn key val) (cddr pairs))))))

(define (thunk? fn)
    (define pinfo (procedure-information fn))
    (and
        (list? pinfo)
        (= 0 (sub1 (length pinfo)))))

(define (sexy-send obj msg)
    (define val (hash-table-ref obj msg))
    (if (eq? (sexy-send val 'null?) 'true)
        (let ((meta (hash-table-ref obj 'meta)))
            (if (eq? ((sexy-send meta 'to) 'bool) 'true)
                (sexy-send meta msg)
                (sexy-null)))
        val))

(define (sexy-error form . args)
    (display form))

(define (sexy-null)
    (define vtable #f)
    (set! vtable (make-hash-table #:initial vtable))
    (hash-table-set! vtable 'null? 'true)
    (hash-table-set! vtable 'to
        (lambda (what)
            (case what
                (('bool) 'false)
                (else (sexy-error "to %s not found!" what)))))
    vtable)


; (obj x 1 y 2 meh (lambda (x) (* x 10)) mah (lambda () 7) resend: ((obj2 'foo 'bar) (obj3 'baz)) auto: (mah) default: true)

(define (sexy-object args resends initial)
    (define this (make-hash-table))
    (define vtable (make-hash-table))
    (define meta (make-hash-table))
    (define (vset! k v)
            (hash-table-set! vtable k v))
    (define (mset! k v)
            (hash-table-set! meta k v))
    (define (set-resend! rlist)
        (let ((delegate (car rlist)) (msgs (cdr rlist)))
            (map (lambda (msg) (mset! msg (lambda () (sexy-send delegate msg)) msgs)))))
    (define (set-default! k v)
        (if ((and (not (hash-table-exists? vtable k)) (not (hash-table-exists? meta k))))
            (mset! k v)))
    (define (keys) (hash-table-keys vtable))
    (define (objvalues) (hash-table-values vtable))
    (define (pairs) (map sexy-pair (hash-table->alist vtable)))     ; FIXME
    (define (clone) (alist->hash-table (hash-table->alist vtable))) ; FIXME
    (define (objset! . kvs) (map-pairs vset! kvs))
    (map-pairs vset! args)
    (map set-resend! resends)
    (map-pairs set-default!
        (list
                'id     (uuid-v4)
                'type   'obj
                'keys   keys
                'values objvalues
                'pairs  pairs
                'clone  clone
                'set!   objset!
                'null?  (sexy-bool 'false)
            ))
    vtable)

(define (sexy-pair x y)
    (cons x y))

(define (sexy-list . this)
    (define (head) (car this))
    (define (tail) (cdr this))
    (define (len) (length this))
    (define (has? x) (member x this))
    (define (mymap fn) (map fn this))
    (sexy-object
        'type 'list
        'head head
        'tail tail
        'len len
        'has? has?
        'map mymap
        'clone
        'scheme
))


(define (sexy-eval code env cont)
    (if (atom? code)
        (cond ((symbol? code) ()))))



; testies

(define kewl (sexy-object 'foo 1 'bar 2 'baz (lambda (x) (* x x))))
(define kewler (sexy-object 'type 'foonballardy 'value 10))
(define kewllist (sexy-list 1 2 3 4 5 7 'beta))

(map
    (lambda (x) (display x) (newline))
    (list
        (sexy-send kewl 'foo)
        ((sexy-send kewl 'keys))
        ((sexy-send kewl 'baz) 10)
        (sexy-send kewler 'type)
        (sexy-send kewler 'value)
        ((sexy-send kewllist 'len))
        ((sexy-send kewllist 'head))
        ((sexy-send kewllist 'tail))
        ((sexy-send kewllist 'map) (lambda (x) (if (number? x) (* x 10) x))) 
))



