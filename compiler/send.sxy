
(lib () send)

(macro prob ()
    %(λ (obj) @rest))

(macro prom ()
    %(λ (msg) @rest))

(def default-messages
    '(type view write print to-bool to-text messages answers? autos resends default))

(proc idk (obj)
    (prom
        (error-object
            'message-not-understood
            %(send $obj (quote $msg))
            "Message not understood."))) 

(def null-messages '(to-symbol apply))

(def control-null (:
    type      (prob null)
    view      (prob "null")
    write     (prob "null")
    print     (prob "null")
    to-text   (prob "null")
    to-bool   (prob false)
    messages  (prob null-messages)
    answers?  (prob (prom (null-messages.has? msg)))
    autos     (prob '(to-symbol))
    resends   (prob ())
    default   (prob (prom null))
    to-symbol (prob null)
    apply (prob
        (error-object
            'apply-null
            null
            "null can not be used as a procedure."))
))

(def bool-messages '(to-symbol to-text not))

(def control-bool (:
    type      (prob 'bool)
    view      (prob (if obj "true" "false"))
    write     (prob (if obj "true" "false"))
    print     (prob (if obj "true" "false"))
    to-text   (prob (if obj "true" "false"))
    to-bool   (prob obj)
    messages  (prob bool-messages)
    answers?  (prob (prom (bool-messages.has? msg)))
    autos     (prob ())
    resends   (prob ())
    default   idk
    to-symbol (prob obj)
    not       (prob (sexy-internal-primitive-not obj))
))

(def int-messages '(to-number zero? pos? neg? odd? even? abs floor ceil round truncate inc dec))

(def control-int (:
    type      (prob 'int)
    view      (prob (sexy-internal-primitive-number-to-text obj))
    write     (prob (sexy-internal-primitive-number-to-text obj))
    print     (prob (sexy-internal-primitive-number-to-text obj))
    to-text   (prob (sexy-internal-primitive-number-to-text obj))
    to-bool   (prob (sexy-internal-primitive-not (= obj 0)))
    messages  (prob int-messages)
    answers?  (prob (prom (int-messages.has? msg)))
    autos     (prob '(to-number zero? pos? neg? odd? even? abs floor ceil round truncate inc dec))
    resends   (prob ())
    default   idk
    to-number (prob obj)
    to-utf8   (prob (sexy-internal-primitive-int-to-rune obj))
    zero?     (prob (= obj 0))
    pos?      (prob (> obj 0))
    neg?      (prob (< obj 0))
    odd?      (prob (= 1 (mod obj 2)))
    even?     (prob (= 0 (mod obj 2)))
    abs       (prob (sexy-internal-primitive-abs obj))
    floor     (prob obj)
    ceil      (prob obj)
    round     (prob obj)
    truncate  (prob obj)
    inc       (prob (+ obj 1))
    dec       (prob (- obj 1))
))

(def rat-messages '(to-number zero? pos? neg? abs floor ceil round truncate))

(def control-rat (:
    type      (prob 'rational)
    view      (prob (sexy-internal-primitive-number-to-text obj))
    write     (prob (sexy-internal-primitive-number-to-text obj))
    print     (prob (sexy-internal-primitive-number-to-text obj))
    to-text   (prob (sexy-internal-primitive-number-to-text obj))
    to-bool   (prob (sexy-internal-primitive-not (= obj 0)))
    messages  (prob rat-messages)
    answers?  (prob (prom (rat-messages.has? msg)))
    autos     (prob '(to-number zero? pos? neg? abs floor ceil round truncate))
    resends   (prob ())
    default   idk
    to-number (prob obj)
    zero?     (prob false)
    pos?      (prob (> obj 0))
    neg?      (prob (< obj 0))
    abs       (prob (sexy-internal-primitive-abs obj))
    floor     (prob (sexy-internal-primitive-floor obj))
    ceil      (prob (sexy-internal-primitive-ceil obj))
    round     (prob (sexy-internal-primitive-round obj))
    truncate  (prob (sexy-internal-primitive-truncate obj))
))

(def real-messages '(to-number zero? pos? neg? abs floor ceil round truncate))

(def control-real (:
    type      (prob 'real)
    view      (prob (sexy-internal-primitive-number-to-text obj))
    write     (prob (sexy-internal-primitive-number-to-text obj))
    print     (prob (sexy-internal-primitive-number-to-text obj))
    to-text   (prob (sexy-internal-primitive-number-to-text obj))
    to-bool   (prob (sexy-internal-primitive-not (= obj 0)))
    messages  (prob real-messages)
    answers?  (prob (prom (real-messages.has? msg)))
    autos     (prob '(to-number zero? pos? neg? abs floor ceil round truncate))
    resends   (prob ())
    default   idk
    to-number (prob obj)
    zero?     (prob (= obj 0))
    pos?      (prob (> obj 0))
    neg?      (prob (< obj 0))
    abs       (prob (sexy-internal-primitive-abs obj))
    floor     (prob (sexy-internal-primitive-floor obj))
    ceil      (prob (sexy-internal-primitive-ceil obj))
    round     (prob (sexy-internal-primitive-round obj))
    truncate  (prob (sexy-internal-primitive-truncate obj))
    abs       (prob (sexy-internal-primitive-abs obj))
))

(def rune-messages '(to-rune to-int code alpha? digit? whitespace? uc? lc? uc lc))

(def control-rune (:
    type      (prob 'rune)
    view      (prob (sexy-internal-primitive-list-to-text (list \\ obj)))
    write     (prob (sexy-internal-primitive-list-to-text (list \\ obj))) ; FIXME \space, \tab, \newline, \return
    print     (prob (sexy-internal-primitive-list-to-text (list obj)))
    to-text   (prob (sexy-internal-primitive-list-to-text (list obj)))
    to-bool   (prob (sexy-internal-primitive-not (sexy-internal-primitive-rune-whitespace? obj)))
    messages  (prob rune-messages)
    answers?  (prob (prom (rune-messages.has? msg)))
    autos     (prob rune-messages)
    resends   (prob ())
    default   idk
    to-rune   (prob obj)
    to-int    (prob (sexy-internal-primitive-text-to-number (sexy-internal-primitive-text obj)))
    code      (prob (sexy-internal-primitive-rune-to-int obj))
    alpha?       (proc (sexy-internal-primitive-rune-alpha? obj))
    digit?       (proc (sexy-internal-primitive-rune-digit? obj))
    whitespace?  (proc (sexy-internal-primitive-rune-whitespace? obj))
    uc?  (proc (sexy-internal-primitive-rune-uc? obj))
    lc?  (proc (sexy-internal-primitive-rune-lc? obj))
    uc   (proc (sexy-internal-primitive-rune-uc obj))
    lc   (proc (sexy-internal-primitive-rune-lc obj))
))

(def symbol-messages '(to-symbol))

(def control-symbol (:
    type      (prob 'symbol)
    view      (prob (sexy-internal-primitive-symbol-to-text obj))
    write     (prob (sexy-internal-primitive-symbol-to-text obj))
    print     (prob (sexy-internal-primitive-symbol-to-text obj))
    to-text   (prob (sexy-internal-primitive-symbol-to-text obj))
    to-bool   (prob true)
    messages  (prob symbol-messages)
    answers?  (prob (prom (symbol-messages.has? msg)))
    autos     (prob symbol-messages)
    resends   (prob ())
    default   idk
    to-symbol (prob obj)
))

(def bin-messages '(to-int to-list size clone set!))

(def control-bin (:
    ; FIXME
    type      (prob 'bin)
    view      (prob (sexy-internal-primitive-bin-to-text obj))
    write     (prob (sexy-internal-primitive-bin-to-text obj))
    print     (prob (sexy-internal-primitive-bin-to-text obj))
    to-text   (prob (sexy-internal-primitive-bin-to-text obj))
    to-bool   (prob true)
    messages  (prob bin-messages)
    answers?  (prob (prom (bin-messages.has? msg)))
    autos     (prob '(to-number to-list size clone))
    resends   (prob ())
    default   idk
    to-int    idk
    to-list   idk
    size      idk
    clone     idk
    set!      idk
))

(def text-messages '(to-symbol to-option to-number to-list to-bin to-stream size empty clone chomp trim ltrim rtrim lpad rpad set! index take drop match split capture replace))

(def control-text (:
    type      (prob 'text)
    view      (prob (cat \" obj \"))
    write     (prob (cat \" obj \"))
    print     (prob obj)
    to-text   (prob obj)
    to-bool   (prob (if (= "" obj) false true))
    messages  (prob text-messages)
    answers?  (prob (prom (text-messages.has? msg)))
    autos     (prob text-messages)
    resends   (prob ())
    default   (prob
                 (prom 
                     (if (number? msg)
                         (if (> (sexy-internal-primitive-text-size obj) msg)
                             (sexy-internal-primitive-text-ref obj msg)
                             (error-object 'out-of-bounds %(send $obj $msg) "text: index out of bounds."))
                         ((idk obj) msg))))
    to-symbol   (prob (sexy-internal-primitive-text-to-symbol obj))
    to-option   (prob (sexy-internal-primitive-text-to-keyword obj))
    to-number   (prob (sexy-internal-primitive-text-to-number obj))
    to-list     (prob (sexy-internal-primitive-text-to-list obj))
    to-bin      (prob (sexy-internal-primitive-text-to-bin obj))
    to-stream   (prob (sexy-internal-primitive-text-to-stream obj))
    size    (prob (sexy-internal-primitive-text-size obj))
    empty?  (prob (= "" obj))
    clone   (prob (sexy-internal-primitive-text-clone obj))
    chomp   (prob (sexy-internal-primitive-text-chomp obj))
    trim    (prob (sexy-internal-primitive-text-trim obj))
    ltrim   (prob (sexy-internal-primitive-text-trim-left obj))
    rtrim   (prob (sexy-internal-primitive-text-trim-right obj))
    lpad    (prob (λ (rune n) (sexy-internal-primitive-text-pad-left obj rune n)))
    rpad    (prob (λ (rune n) (sexy-internal-primitive-text-pad-right obj rune n)))
    set!    (prob (λ (n rune) (sexy-internal-primitive-text-set! obj n rune)))
    index   (prob (λ (substr) (sexy-internal-primitive-text-subtext-index obj substr)))
    take    (prob (λ (n) (sexy-internal-primitive-text-take obj n)))
    drop    (prob (λ (n) (sexy-internal-primitive-text-drop obj n)))
    match (prob
        (proc (regex)
            (def flags (or opt.flags ""))
            (sexy-internal-primitive-text-match obj regex flags)))
    split (prob
        (proc (regex)
            (def flags (or opt.flags ""))
            (sexy-internal-primitive-text-split obj regex flags)))
    capture (prob
        (proc (regex)
            (def flags (or opt.flags ""))
            (sexy-internal-primitive-text-capture obj regex flags)))
    replace (prob
        (proc (regex replacement)
            (def flags (or opt.flags ""))
            (sexy-internal-primitive-text-replace obj regex flags)))
))

(def control-env (:))
(def control-pair (:))
(def control-vector (:))
(def control-record (:))
(def control-λ (:))
(def control-proc (:))
(def control-stream (:))
(def control-fs-socket (:))
(def control-tcp-socket (:))

(def control (:
    null         control-null
    bool         control-bool
    int          control-int
    rational     control-rat
    real         control-real
    rune         control-rune
    symbol       control-symbol
    bin          control-bin
    text         control-text
    environment  control-env
    pair         control-pair
    vector       control-vector
    record       control-record
    λ            control-λ
    proc         control-proc
    stream       control-stream
    fs-socket    control-fs-socket
    tcp-socket   control-tcp-socket
))

(def object-defaults (:
    type    (λ (obj) 'object)
    view    (λ (obj) %(object: @(send obj 'messages)))
    write   (λ (obj) %(object: @(send obj 'messages)))
    print   (λ (obj) %(object: @(send obj 'messages)))
    to-bool (λ (obj) true)
))

(proc has-msg? (obj msg)
    ((sexy-internal-object-answers? obj) msg))

(proc autofire (obj msg def-thunk)
    (if (has-msg? obj msg)
        (let (method (sexy-internal-object-get-message obj msg))
            (if (sexy-internal-list-has? (sexy-internal-object-autos obj) msg)
                (method)
                method))
        (def-thunk)))

(proc send (obj msg)
    (def t (sexy-internal-get-object-type obj))
    (if (sexy-internal-record-has? control t)
        (let (dispatcher (sexy-internal-record-get control t))
            (if (sexy-internal-record-has? dispatcher msg)
                ((sexy-internal-record-get dispatcher msg) obj)
                (((sexy-internal-record-get dispatcher 'default) obj) msg)))
        (case msg
            ; begin with unshadowable reflection messages
            (answers?)
                (sexy-internal-object-answers? obj)
            (autos)
                (sexy-internal-object-autos obj)
            (default)
                (sexy-internal-object-default obj)
            (messages)
                (sexy-internal-object-messages obj)
            (resends)
                (sexy-internal-object-resends obj)
            ; end reflection; begin shadowable messages with defaults
            (type view write print to-bool)
                (autofire obj msg (λ () ((object-defaults msg) obj)))
            ; regular messages
            default: 
                (autofire obj msg (λ () ((sexy-internal-object-default obj) msg))))))


(rem:
"

pair

view
to-bool -> () is false, else true
to-text
to-list
to-text -> all items must be runes
to-vector
to-record
size
empty?
reverse
head key car
tail val cdr
(cons x)
(has? x)
(append x)
(take n)
(drop n)
(apply (n) null)
(fold init proc)
(reduce init proc)
(map proc)
(filter proc)
(sort op)
(each proc)


vector

view
to-bool -> (#) is false, else true
to-text -> all items must be runes
to-list
to-vector
to-record
size
empty?
clone
pairs
(has? item)
(index item) -> n or null
(put n v n v n v)   ; functional
(set! n v n v n v)  ; imperative
(append x)
(take n)
(drop n)
(apply (n) null)
(fold init proc)
(reduce init proc)
(map proc)
(filter proc)
(sort op)
(each proc)


record

view
to-bool
to-list   -> alist
to-record
to-text
size
empty?
keys
values
pairs
clone
(get k)
(put k v k2 v2 ...)
(rm k k2 k3)
(set! k 1 k2 2 k3 3 ...)
(del! k k2 k3 ...)
(has? k)
(apply (k) null)
(merge r)
(fold init proc)
(reduce init proc)
(map proc) -> record
(filter proc) -> record
(sort op) -> alist
(each proc)


env (standard | repl | immutable | wild)

view
mama
to-env
to-bool
to-text
to-list
to-record
empty?
(def! x 1 y 2 z 3 ...)
(get x)
(set! x 2 y 3 z 5 ...)
(has? x)     ; local
(del! x y z ...)
(lookup x)   ; local or ancestral
(lookup-list '(x y z))
(extend u 7 v 8)
(partition '(x y z))
(expand form)
(eval expr)


proc / λ / operator

view
to-bool
to-text
arity
formals
code
env
(apply (args) (: opts))


stream

view
to-bool
input?
output?
open?
close

source

view
to-bool -> open?
to-text -> printable
ready?
read
read-rune
peek-rune
read-line
read-lines -> to-list
read-text -> slurp
read-sexy -> all sexy forms to list
(assert-rune "runes")
(skip n)
(skip-while "runes")
(skip-until "runes")
(read-tokens n)
(read-token-while "runes")
(read-token-until "runes")
(read-token-if proc)
(each proc) ?

sink

flush
nl -> newline
(write obj) -> obj.view
(print obj) -> obj.to-text
(say obj)   -> obj.print + obj.nl


fs-socket

to-bool -> true
ready? -> true if there is a connection ready to be accepted
accept -> accepts a connection and returns a socket
close -> shut down the TCP listener
path -> returns the file system path of the listener

socket messages

to-bool -> true
close -> close the socket
path -> file system path the socket is connected to


tcp-socket

to-bool -> true
ready? -> true if there is a connection ready to be accepted
accept -> accepts a connection and returns a socket
close -> shut down the TCP listener
ip -> returns local IP address
port -> returns the port number of the listener

socket messages

to-bool -> true
close -> close the socket
local-addr -> local IP address of the socket
local-port -> local port number of the socket
remote-addr -> remote IP address of the socket
remote-port -> remote port number of the socket
"
)


; 
; (define (sexy-ho code obj cont err)
;     (sexy-apply
;         (sexy-compile-method code)
;         (list obj)
;         'null
;         cont
;         err))
; 
; (define (sexy-send-empty obj msg cont err)
;     (case msg
;         ((type empty? autos resends default view to-bool to-text to-list head tail key val car cdr size)
;             (cont
;                 (case msg
;                     ((type) 'list)
;                     ((autos) '(view empty? to-bool to-text to-list head tail key val size))
;                     ((resends) '())
;                     ((default) default-default)
;                     ((empty?) #t)
;                     ((to-bool) #f)
;                     ((view to-list) '())
;                     ((to-text) "()")
;                     ((head tail key val car cdr) 'null)
;                     ((size) 0))))
;         (else (sexy-send-list obj msg cont err))))
; 
; (define (sexy-send-list obj msg cont err)
;     (define msgs
;         '(type empty? view to-bool to-list to-text to-vector to-record head key car tail val cdr cons
;           size reverse has? append take drop apply fold reduce each map filter sort))
;     (define (ldefault msg)
;         (if (number? msg)
;             (if (> (length obj) msg)
;                 (cont (list-ref obj msg))
;                 (err (sexy-error-object 'out-of-bounds `(,obj ,msg) "list: index out of bounds.") cont))
;             (idk obj msg cont err)))
;     (case msg
;         ((type autos resends default empty? view to-bool to-list to-text to-vector head key car tail val cdr cons size reverse has? append take drop apply messages responds?)
;             (cont
;                 (case msg
;                     ((type) 'list)
;                     ((empty?) #f)
;                     ((autos) '(view empty? to-bool to-text to-list to-vector to-record head tail key val size reverse))
;                     ((resends) '())
;                     ((default) ldefault)
;                     ((view) (map sexy-view obj))
;                     ((to-text) (apply string obj))
;                     ((to-bool) #t)
;                     ((to-list) obj)
;                     ((to-vector) (list->vector obj))
;                     ((head key car) (car obj))
;                     ((tail val cdr) (cdr obj))
;                     ((cons) (lambda (v) (cons v obj)))
;                     ((size) (length obj))
;                     ((clone) (list-copy obj))
;                     ((reverse) (reverse obj))
;                     ((has?)
;                         (lambda (item)
;                             (if (member item obj)
;                                 #t
;                                 #f)))
;                     ((append) (lambda (other) (append obj other)))
;                     ((take) (lambda (n) (take obj n)))
;                     ((drop) (lambda (n) (drop obj n)))
;                     ((messages) msgs)
;                     ((responds?)
;                         (lambda (msg)
;                             (or
;                                 (and (number? msg) (> (length obj) msg))
;                                 (if (member msg msgs) #t #f))))
;                     ((apply)
;                         (sexy-proc
;                             primitive-type
;                             'pair
;                             (lambda (args opts cont err)
;                                 (if (pair? (car args))
;                                     (sexy-send-list obj (caar args) cont err)
;                                     (err (sexy-error-object 'bad-message! `(,obj ,args ,opts) "Message not understood.") cont))))))))
;         ((to-record)
;             (if (not (every pair? obj))
;                 (err (sexy-error-object 'not-an-associative-list! `(send ,obj to-record) "list: to-record only works on associative lists." ) cont)
;                 (let ((r (sexy-record)))
;                     (define vars (htr r 'vars))
;                     (for-each (lambda (p) (hts! vars (car p) (cdr p))) obj)
;                     (cont r))))
;         ((fold)
;             (sexy-ho
;                 '(λ (xs)
;                     (λ (acc funk)
;                         (if xs.empty?
;                             acc
;                             (xs.tail.fold (funk acc xs.head) funk))))
;                 obj
;                 cont
;                 err))
;         ((reduce)
;             (sexy-ho
;                 '(λ (xs)
;                     (λ (acc funk)
;                         (if xs.empty?
;                             acc
;                             (funk xs.head (xs.tail.reduce acc funk)))))
;                 obj
;                 cont
;                 err))
;         ((each)
;             (sexy-ho
;                 '(λ (xs)
;                     (λ (funk)
;                         (if xs.empty?
;                             null
;                             (seq
;                                 (funk xs.head)
;                                 (xs.tail.each funk)))))
;                 obj
;                 cont
;                 err))
;         ((map)
;             (sexy-ho
;                 '(λ (xs)
;                     (λ (funk)
;                         (xs.reduce '() (λ (x y) (pair (funk x) y)))))
;                 obj
;                 cont
;                 err))
;         ((filter)
;             (sexy-ho
;                 '(λ (xs)
;                     (λ (funk)
;                         (xs.reduce '() (λ (x y) (if (funk x) (pair x y) y)))))
;                 obj
;                 cont
;                 err))
;         ((sort)
;             (sexy-ho
;                 '(λ (xs)
;                     (λ (funk)
;                         (def merge (λ (a b)
;                             (if a.size.zero?
;                                 b
;                                 (if b.size.zero?
;                                     a
;                                     (if (funk a.head b.head)
;                                         (pair a.0 (merge a.tail b))
;                                         (pair b.0 (merge a b.tail)))))))
;                         (def sort (λ (yarr)
;                             (def len yarr.size)
;                             (if (< len 2)
;                                 yarr
;                                 (seq
;                                     (def half (send (/ len 2) 'floor))
;                                     (merge (sort (yarr.take half)) (sort (yarr.drop half)))))))
;                         (sort xs)))
;                 obj
;                 cont
;                 err))
;         (else (ldefault msg))))
; 
; (define (sexy-send-pair obj msg cont err)
;     (define msgs
;         '(empty? view to-text to-bool to-list to-record head key car tail val cdr cons size clone))
;     (define msgs+ (append msgs '(messages responds? type)))
;     (if (member msg msgs+)
;         (cont 
;             (case msg
;                 ((type) 'pair)
;                 ((view to-text) obj)
;                 ((autos) '(view empty? to-bool to-text to-list to-record head tail key val size))
;                 ((resends) '())
;                 ((default) default-default)
;                 ((to-bool) #t)
;                 ((to-list) (list (car obj) (cdr obj)))
;                 ((to-record) (sexy-record (car obj) (cdr obj)))
;                 ((head key car) (car obj))
;                 ((tail val cdr) (cdr obj))
;                 ((cons) (lambda (v) (cons v obj)))
;                 ((size) 2)
;                 ((clone) (cons (car obj) (cdr obj)))
;                 ((messages) msgs)
;                 ((responds?)
;                     (lambda (msg)
;                         (if (member msg msgs) #t #f)))))
;         (idk obj msg cont err)))
; 
; (define (sexy-send-primitive obj msg cont err)
;     (define msgs '(view code to-bool to-text env arity apply))
;     (define msgs+ (append msgs '(messages responds? type autos resends default)))
;     (if (member msg msgs+)
;         (cont 
;             (case msg
;                 ((type) 'proc)
;                 ((view) primitive-type)
;                 ((code) '0xDEADBEEF)
;                 ((to-bool) #t)
;                 ((to-text) "0xDEADBEEF")
;                 ((autos) '(view code to-bool to-text env arity))
;                 ((resends) '())
;                 ((default) default-default)
;                 ((env) 'global)
;                 ((arity)
;                     (let ((pinfo (procedure-information obj)))
;                         (if (list? pinfo)
;                             (sub1 (length pinfo))
;                             '*)))
;                 ((messages) msgs)
;                 ((responds?)
;                     (lambda (msg)
;                         (if (member msg msgs) #t #f)))
;                 ((apply)
;                     (lambda (args opts)
;                         (apply obj args)))))
;         (idk obj msg cont err)))
; 
; (define (sexy-send-record obj msg cont err)
;     (define msgs
;         '(view size clone to-bool get put set! rm del! has? apply keys values pairs to-list to-opt to-text merge fold reduce map filter))
;     (define vars (htr obj 'vars))
;     (define (rdefault msg)
;         (if (hte? vars msg)
;             (htr vars msg)
;             'null))
;     (case msg
;         ((type view size autos resends default clone to-bool get put set! rm del! has? apply keys values pairs to-list to-opt to-text merge messages responds?)
;             (cont
;                 (case msg
;                     ((type) 'record)
;                     ((view to-text)
;                         (let ((keys (htks vars)))
;                             (cons
;                                 (string->keyword "record")
;                                 (fold
;                                     (lambda (p xs)
;                                         (cons (car p) (cons (sexy-view (cdr p)) xs)))
;                                     '()
;                                     (hash-table->alist vars)))))
;                     ((size) (hash-table-size vars))
;                     ((autos) '(view size clone to-bool to-list to-text keys values pairs))
;                     ((resends) '())
;                     ((default) rdefault)
;                     ((clone)
;                         (let ((noob (sexy-record)))
;                             (hts! noob 'vars (hash-table-copy vars))
;                             noob))
;                     ((to-bool)
;                         (> (hash-table-size vars) 0))
;                     ((get)
;                         (lambda (k)
;                             (if (hte? vars k)
;                                 (htr vars k)
;                                 'null)))
;                     ((put)
;                         (lambda args
;                             (define noob (sexy-record))
;                             (hts! noob 'vars (hash-table-copy vars))
;                             (sexy-send-record
;                                 noob
;                                 'set!
;                                 (lambda (setter!)
;                                     (apply setter! args)
;                                     noob)
;                                 err)))
;                     ((set!)
;                         (lambda args
;                             (for-pairs (lambda (k v) (hts! vars k v)) args)
;                             'null))
;                     ((rm)
;                         (lambda args
;                             (define noob (sexy-record))
;                             (hts! noob 'vars (hash-table-copy vars))
;                             (sexy-send-record
;                                 noob
;                                 'del!
;                                 (lambda (deleter!)
;                                     (apply deleter! args)
;                                     noob)
;                                 err)))
;                     ((del!)
;                         (lambda args
;                             (map (lambda (k) (htd! vars k)) args)
;                             'null))
;                     ((has?)
;                         (lambda (x)
;                             (hte? vars x)))
;                     ((apply)
;                         (sexy-proc
;                             primitive-type
;                             'record
;                             (lambda (args opts cont err)
;                                 (sexy-send-record obj (caar args) cont err))))
;                     ((keys) (htks vars))
;                     ((values) (htvs vars))
;                     ((pairs to-list) (hash-table->alist vars))
;                     ((to-opt)
;                         (fold
;                             (lambda (p xs)
;                                 (cons (symbol->keyword (car p)) (cons (cdr p) xs)))
;                             '()
;                             (hash-table->alist vars)))
;                     ((messages) msgs)
;                     ((responds?)
;                         (lambda (msg)
;                             (or 
;                                 (hte? vars msg)
;                                 (if (member msg msgs) #t #f))))
;                     ((merge)
;                         (lambda (other)
;                             (define nuvars (hash-table-merge (htr other 'vars) vars))
;                             (define noob (mkht))
;                             (hts! noob 'type 'record)
;                             (hts! noob 'vars nuvars)
;                             noob)))))
;             ((fold) (sexy-send-list
;                         (hash-table->alist vars)
;                         'fold
;                         cont
;                         err))
;             ((reduce) (sexy-send-list
;                         (hash-table->alist vars)
;                         'reduce
;                         cont
;                         err))
;             ((map)
;                 (sexy-ho
;                     '(λ (rec)
;                         (λ (funk)
;                             (def mapped (rec.to-list.map funk))
;                             mapped.to-record))
;                     obj
;                     cont
;                     err))
;             ((filter) 
;                 (sexy-ho
;                     '(λ (rec)
;                         (λ (funk)
;                             (def mapped (rec.to-list.filter funk))
;                             mapped.to-record))
;                     obj
;                     cont
;                     err))
;             (else (cont (rdefault msg)))))
; 
; (define (sexy-send-object obj msg cont err)
;     (define fields (htr obj 'fields))
;     (define resends (htr obj 'resends))
;     (define autos (htr obj 'autos))
;     (define (get-msgs)
;         (append (hash-table-keys fields) (hash-table-keys resends)))
;     (if (hte? fields msg)
;         (let ((v (htr fields msg)))
;             (if (hte? autos msg)
;                 (sexy-apply v '() 'null cont err) ; exec the thunk
;                 (cont v)))
;         (if (hte? resends msg)
;             (sexy-send (htr resends msg) msg cont err)
;             (case msg
;                 ((type) (cont 'object))
;                 ((view) (cont `(,(if (hte? fields 'type) (htr fields 'type) 'object) ,@(get-msgs))))
;                 ((to-text) (cont "object"))
;                 ((to-bool) (cont (not (eq? 0 (length (hash-table-keys fields))))))
;                 ((responds?) (cont (lambda (x) (hte? fields x))))
;                 ((messages) (cont (get-msgs)))
;                 ((autos) (cont (hash-table-keys autos)))
;                 ((resends) (cont (hash-table-keys resends)))
;                 ((default) (cont (htr obj 'default)))
;                 (else (sexy-apply (htr obj 'default) (list msg) 'null cont err))))))
; 
; (define (sexy-send-proc obj msg cont err)
;     (define msgs '(type view to-bool to-text arity code env formals apply))
;     (case msg
;         ((type) (cont (htr obj 'type)))
;         ((view) (cont `(,(htr obj 'type) ,(htr obj 'formals) ...)))
;         ((to-bool) (cont #t))
;         ((to-text) (cont (htr obj 'code)))
;         ((arity code env formals) (cont (htr obj msg)))
;         ((apply)
;             (cont 
;                 (sexy-proc
;                     primitive-type
;                     'proc
;                     (lambda (args opts cont err)
;                         (if (< (length args) 2)
;                             (err (sexy-error-object 'arity `((send ,obj apply) ,args) "proc.apply requires 2 arguments!") cont)
;                             (sexy-apply obj (car args) (cadr args) cont err))))))
;         ((messages) (cont msgs))
;         ((responds?) (cont (lambda (msg) (if (member msg msgs) #t #f))))
;         ((autos) (cont '(view to-bool to-text arity code env formals)))
;         ((resends) (cont '()))
;         ((default) (cont default-default))
;         (else (idk obj msg cont err))))
; 
; (define (sexy-send-env obj msg cont err)
;     (define msgs '(view to-text def! set! has? get del! pairs lookup mama extend eval expand))
;     (case msg
;         ((get has? to-bool keys values pairs)
;             (sexy-send-record (htr obj 'vars) msg cont err))
;         ((type) (cont 'env))
;         ((view to-text)
;             (cont
;                 (cons (string->keyword "env")
;                       (cdr (sexy-view (htr obj 'vars))))))
;         ((autos) (cont '(view to-text to-bool keys values pairs)))
;         ((resends) (cont '()))
;         ((default) (cont default-default))
;         ((def!)
;             (sexy-send-record (htr obj 'vars) 'set! cont err))
;         ((rm!)
;             (sexy-send-record (htr obj 'vars) 'del! cont err))
;         ((set!)
;             (cont
;                 (sexy-proc
;                     primitive-type
;                     'env
;                     (lambda (args opts cont err)
;                         (define len (length args))
;                         (if (not (> len 1))
;                             (err (sexy-error-object 'env-error `(set! ,@args) "env.set! requires at least 2 arguments.") cont)
;                             (if (not (= 0 (modulo len 2)))
;                                 (err (sexy-error-object 'env-error `(set! ,@args) "env.set! requires an even number of arguments.") cont)
;                                 (let loop ((name (car args)) (val (cadr args)) (rest (cddr args)))
;                                     (update!
;                                         obj
;                                         name
;                                         val
;                                         (lambda (_)
;                                             (if (pair? rest)
;                                                 (loop (car rest) (cadr rest) (cddr rest))
;                                                 (cont 'null)))
;                                         err))))))))
;         ((del!)
;             (cont
;                 (sexy-proc
;                     primitive-type
;                     'env
;                     (lambda (args opts cont err)
;                         (if (not (> (length args) 0))
;                             (err (sexy-error-object 'env-error `(del! ,@args) "env.del! requires at least 1 argument.") cont)
;                             (let loop ((name (car args)) (rest (cdr args)))
;                                 (delete!
;                                     obj
;                                     name
;                                     (lambda (_)
;                                         (if (pair? rest)
;                                             (loop (car rest) (cdr rest))
;                                             (cont 'ok)))
;                                     err)))))))
;         ((lookup)
;             (cont
;                 (sexy-proc
;                     primitive-type
;                     'env
;                     (lambda (args opts cont err)
;                         (lookup
;                             obj
;                             (car args)
;                             (lambda (val)
;                                 (cont
;                                     (if (eq? val not-found)
;                                         'null
;                                         val)))
;                             err)))))
;         ((extend)
;             (cont
;                 (sexy-proc
;                     primitive-type
;                     'env
;                     (lambda (args opts cont err)
;                         (let loop ((names '()) (vals '()) (left args))
;                             (if (eq? '() left)
;                                 (extend obj names vals cont err)
;                                 (loop (cons (car left) names) (cons (cadr left) vals) (cddr args))))))))
;         ((mama) (cont (htr obj 'mama)))
;         ((eval)
;             (cont
;                 (lambda (code)
;                     (sexy-eval code obj))))
;         ((expand)
;             (cont
;                 (lambda (code)
;                     (sexy-expand code obj))))
;         ((messages) (cont msgs))
;         ((responds?) (cont (lambda (msg) (if (member msg msgs) #t #f))))
;         (else (idk obj msg cont err))))
; 
; (define (sexy-send-vector obj msg cont err)
;     (define msgs '(view to-bool to-text to-list pairs size clone has? set! apply fold reduce map filter sort))
;     (define (vdefault msg)
;         (if (number? msg)
;             (if (> (vector-length obj) msg)
;                 (cont (vector-ref obj msg))
;                 (err (sexy-error-object 'out-of-bounds `(,obj ,msg) "vector: index out of bounds.") cont))
;             (idk obj msg cont err)))
;     (case msg
;         ((type view autos resends default to-bool to-text to-list pairs size clone has? set! apply messages responds?)
;             (cont 
;                 (case msg
;                     ((type) 'vector)
;                     ((view) (cons (string->keyword "vector") (map sexy-view (vector->list obj))))
;                     ((to-bool) (not (eq? (vector-length obj) 0)))
;                     ((to-list) (vector->list obj))
;                     ((to-text) (apply string (vector->list obj)))
;                     ((autos) '(view to-text to-bool to-list size pairs clone))
;                     ((resends) '())
;                     ((default) vdefault)
;                     ((pairs) (vector->list (vector-map (lambda (i x) (cons i x)) obj)))
;                     ((size) (vector-length obj))
;                     ((clone) (vector-copy obj))
;                     ((has?)
;                         (lambda (item)
;                             (if (vector-index
;                                     (lambda (x) (eq? x item))
;                                     obj)
;                                 #t
;                                 #f)))
;                     ((set!)
;                         (lambda (idx val)
;                             (if (> idx (vector-length obj))
;                                 (err (sexy-error-object 'out-of-bounds `(,obj ,msg) "vector: index out of bounds.") cont)
;                                 (begin
;                                     (vector-set! obj idx val)
;                                     obj))))
;                     ((messages) msgs)
;                     ((responds?)
;                         (lambda (msg)
;                             (or
;                                 (and (number? msg) (> (vector-length obj) msg))
;                                 (if (member msg msgs) #t #f))))
;                     ((apply)
;                         (sexy-proc
;                             primitive-type
;                             'pair
;                             (lambda (args opts cont err)
;                                 (sexy-send-vector obj (caar args) cont err)))))))
;         ((fold)
;             (sexy-ho
;                 '(λ (vec)
;                     (λ (acc funk)
;                         (vec.to-list.fold acc funk)))
;                 obj
;                 cont
;                 err))
;         ((reduce)
;             (sexy-ho
;                 '(λ (vec)
;                     (λ (acc funk)
;                         (vec.to-list.reduce acc funk)))
;                 obj
;                 cont
;                 err))
;         ((map)
;             (sexy-ho
;                 '(λ (vec)
;                     (λ (funk)
;                         (def mapped (vec.to-list.map funk))
;                         mapped.to-vector))
;                 obj
;                 cont
;                 err))
;         ((filter)
;             (sexy-ho
;                 '(λ (vec)
;                     (λ (funk)
;                         (def mapped (vec.to-list.filter funk))
;                         mapped.to-vector))
;                 obj
;                 cont
;                 err))
;         ((sort)
;             (sexy-ho
;                 '(λ (vec)
;                     (λ (funk)
;                         (def sorted (vec.to-list.sort funk))
;                         sorted.to-vector))
;                 obj
;                 cont
;                 err))
;         (else
;             (vdefault msg))))
; 
; (define (sexy-send-stream obj msg cont err)
;     (case msg
;         ((type view resends default to-text to-bool to-stream input? output? open? resends default)
;             (cont 
;                 (case msg
;                     ((type) 'stream)
;                     ((view to-text) obj)
;                     ((to-bool) #t)
;                     ((to-stream) obj)
;                     ((resends) '())
;                     ((default) (cont default-default))
;                     ((input?) (input-port? obj))
;                     ((output?) (output-port? obj))
;                     ((open?) (not (port-closed? obj))))))
;         (else
;             (if (input-port? obj)
;                 (sexy-send-input-stream obj msg cont err) 
;                 (sexy-send-output-stream obj msg cont err)))))
; 
; (define (sexy-send-input-stream obj msg cont err)
;     (define msgs
;         '(view to-bool input? output? open? close
;           ready? read read-rune peek-rune read-line read-text assert-rune skip skip-while skip-until
;           read-token read-token-while read-token-until read-token-if to-list to-text read-sexy))
;     (case msg
;         ((ready? autos read read-rune peek-rune read-line read-text assert-rune skip skip-while skip-until
;           read-token read-token-while read-token-until read-token-if to-list to-text read-sexy
;           messages responds?)
;             (if (port-closed? obj)
;                 (err (sexy-error-object 'input-stream-closed `(send ,obj ,msg) "Input stream closed.") cont)
;                 (cont 
;                     (case msg
;                         ((autos) '(view to-text to-bool to-list ready? input? output? open? read read-rune peek-rune read-line read-text read-sexy)) 
;                         ((ready?) (char-ready? obj))
;                         ((read) (sexy-read obj))
;                         ((read-rune) (read-char obj))
;                         ((peek-rune) (peek-char obj))
;                         ((read-line) (read-line obj))
;                         ((read-text) (read-string #f obj))
;                         ((read-sexy) (sexy-read-file obj))
;                         ((assert-rune)
;                             (sexy-proc
;                                 primitive-type
;                                 'stream
;                                 (lambda (args opts cont err)
;                                     (if (not (= 1 (length args)))
;                                         (err (sexy-error-object 'arity `assert-rune "stream.assert-rune requires one text argument") cont)
;                                         (let ((runes (string->list (car args))))
;                                             (define next (read-char obj))
;                                             (if (member next runes)
;                                                 (cont next)
;                                                 (err (sexy-error-object 'assert-rune-FAIL `(assert-rune next ,(car args)) "Assertion FAIL") cont)))))))
;                         ((skip)
;                             (lambda (n)
;                                 (read-string n obj)
;                                 'null))
;                         ((skip-while)
;                             (lambda (s)
;                                 (define runes (string->list s))
;                                 (let loop ((tok (peek-char obj)))
;                                     (if (member tok runes)
;                                         (begin
;                                             (read-char obj)
;                                             (loop (peek-char obj)))
;                                         'null))))
;                         ((skip-until)
;                             (lambda (s)
;                                 (define runes (string->list s))
;                                 (let loop ((tok (peek-char obj)))
;                                     (if (member tok runes)
;                                         'null
;                                         (begin
;                                             (read-char obj)
;                                             (loop (peek-char obj)))))))
;                         ((read-token read-tokens)
;                             (lambda (n)
;                                 (read-string n obj)))
;                         ((read-token-while)
;                             (lambda (s)
;                                 (define runes (string->list s))
;                                 (let loop ((tok (peek-char obj)) (acc '()))
;                                     (if (member tok runes)
;                                         (let ((t (read-char obj)))
;                                             (loop (peek-char obj) (cons t acc)))
;                                         (list->string (reverse acc))))))
;                         ((read-token-until)
;                             (lambda (s)
;                                 (define runes (string->list s))
;                                 (let loop ((tok (peek-char obj)) (acc '()))
;                                     (if (member tok runes)
;                                         (list->string (reverse acc))
;                                         (let ((t (read-char obj)))
;                                             (loop (peek-char obj) (cons t acc)))))))
;                         ((read-token-if)
;                             (sexy-proc
;                                 primitive-type
;                                 'env
;                                 (lambda (args opts cont err)
;                                     (if (not (= 1 (length args)))
;                                         (err (sexy-error-object 'arity `(read-token-if) "read-token-if: requires one proc argument.") cont)
;                                         (let ((pred (car args)))
;                                             (let loop ((tok (peek-char obj)) (acc '()))
;                                                 (sexy-apply
;                                                     pred
;                                                     (list tok)
;                                                     'null
;                                                     (lambda (rv)
;                                                         (sexy-bool
;                                                             rv
;                                                             (lambda (ok)
;                                                                 (if ok
;                                                                     (let ((t (read-char obj)))
;                                                                         (loop (peek-char obj) (cons t acc)))
;                                                                     (cont (list->string (reverse acc)))))
;                                                             err))
;                                                     err)))))))
;                         ((messages) msgs)
;                         ((responds?)
;                             (lambda (msg)
;                                 (if (member msg msgs) #t #f)))
;                         ((to-list read-lines) (read-lines obj))))))
;         ((close) (close-input-port obj) (cont 'null))
;         (else (idk msg obj cont err))))
; 
; (define (sexy-send-output-stream obj msg cont err)
;     (define msgs
;         '(view to-text to-bool input? output? open? write print say nl flush close))
;     (case msg
;         ((write print say nl autos)
;             (if (port-closed? obj)
;                 (err (sexy-error-object 'output-stream-closed `(send ,obj ,msg) "Output stream closed.") cont)
;                 (cont
;                     (case msg
;                         ((autos) '(view to-text to-bool ready? input? output? open? nl close)) 
;                         ((write)
;                             (lambda (x)
;                                 (sexy-write x obj)
;                                 'null))
;                         ((print)
;                             (lambda (x)
;                                 (sexy-print x obj)
;                                 'null))
;                         ((say)
;                             (lambda (x)
;                                 (sexy-print x obj)
;                                 (newline obj)
;                                 'null))
;                         ((nl) (newline obj) 'null)))))
;         ((messages) (cont msgs))
;         ((responds?)
;             (cont
;                 (lambda (msg)
;                     (if (member msg msgs) #t #f))))
;         ((flush) (flush-output obj) (cont 'null))
;         ((close) (close-output-port obj) (cont 'null))
;         (else (idk msg obj cont err))))
; 
; (define (sexy-send-eof obj msg cont err)
;     (case msg
;         ((type) (cont 'EOF))
;         ((view) (cont 'EOF))
;         ((to-bool) (cont #f))
;         ((to-text) (cont "END OF LINE."))
;         ((autos) '(view to-text to-bool))
;         ((resends) '())
;         ((default) (cont default-default))
;         ((apply) (err (sexy-error-object 'eof-is-not-applicable '(EOF ...) "EOF objects can not be used as procedures.") cont))
;         (else (idk msg obj cont err))))

