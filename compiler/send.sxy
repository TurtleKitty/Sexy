
(lib () sender)

(macro prob ()
    %(λ (obj) @rest))

(macro prom ()
    %(λ (msg) @rest))

(def default-messages
    '(type view write print to-bool to-text messages answers? autos resends default))

(proc idk (obj)
    (prom
        (error-object
            'message-not-understood
            %(send $obj (quote $msg))
            "Message not understood."))) 

(def null-messages '(to-symbol apply))

(def control-null (:
    type      (prob 'null)
    view      (prob "null")
    write     (prob "null")
    print     (prob "null")
    to-text   (prob "null")
    to-bool   (prob false)
    messages  (prob null-messages)
    answers?  (prob (prom (null-messages.has? msg)))
    autos     (prob '(to-symbol))
    resends   (prob ())
    default   (prob (prom null))
    to-symbol (prob null)
    apply (prob
        (error-object
            'apply-null
            null
            "null can not be used as a procedure."))
))

(def bool-messages '(to-symbol to-text not))

(def control-bool (:
    type      (prob 'bool)
    view      (prob (if obj "true" "false"))
    write     (prob (if obj "true" "false"))
    print     (prob (if obj "true" "false"))
    to-text   (prob (if obj "true" "false"))
    to-bool   (prob obj)
    messages  (prob bool-messages)
    answers?  (prob (prom (bool-messages.has? msg)))
    autos     (prob ())
    resends   (prob ())
    default   idk
    to-symbol (prob obj)
    not       (prob (sexy-internal-primitive-not obj))
))

(def int-messages '(to-number zero? pos? neg? odd? even? abs floor ceil round truncate inc dec))

(def control-int (:
    type      (prob 'int)
    view      (prob (sexy-internal-primitive-number-to-text obj))
    write     (prob (sexy-internal-primitive-number-to-text obj))
    print     (prob (sexy-internal-primitive-number-to-text obj))
    to-text   (prob (sexy-internal-primitive-number-to-text obj))
    to-bool   (prob (sexy-internal-primitive-not (= obj 0)))
    messages  (prob int-messages)
    answers?  (prob (prom (int-messages.has? msg)))
    autos     (prob '(to-number zero? pos? neg? odd? even? abs floor ceil round truncate inc dec))
    resends   (prob ())
    default   idk
    to-number (prob obj)
    to-utf8   (prob (sexy-internal-primitive-int-to-rune obj))
    zero?     (prob (= obj 0))
    pos?      (prob (> obj 0))
    neg?      (prob (< obj 0))
    odd?      (prob (= 1 (mod obj 2)))
    even?     (prob (= 0 (mod obj 2)))
    abs       (prob (sexy-internal-primitive-abs obj))
    floor     (prob obj)
    ceil      (prob obj)
    round     (prob obj)
    truncate  (prob obj)
    inc       (prob (+ obj 1))
    dec       (prob (- obj 1))
))

(def rat-messages '(to-number zero? pos? neg? abs floor ceil round truncate))

(def control-rat (:
    type      (prob 'rational)
    view      (prob (sexy-internal-primitive-number-to-text obj))
    write     (prob (sexy-internal-primitive-number-to-text obj))
    print     (prob (sexy-internal-primitive-number-to-text obj))
    to-text   (prob (sexy-internal-primitive-number-to-text obj))
    to-bool   (prob (sexy-internal-primitive-not (= obj 0)))
    messages  (prob rat-messages)
    answers?  (prob (prom (rat-messages.has? msg)))
    autos     (prob '(to-number zero? pos? neg? abs floor ceil round truncate))
    resends   (prob ())
    default   idk
    to-number (prob obj)
    zero?     (prob false)
    pos?      (prob (> obj 0))
    neg?      (prob (< obj 0))
    abs       (prob (sexy-internal-primitive-abs obj))
    floor     (prob (sexy-internal-primitive-floor obj))
    ceil      (prob (sexy-internal-primitive-ceil obj))
    round     (prob (sexy-internal-primitive-round obj))
    truncate  (prob (sexy-internal-primitive-truncate obj))
))

(def real-messages '(to-number zero? pos? neg? abs floor ceil round truncate))

(def control-real (:
    type      (prob 'real)
    view      (prob (sexy-internal-primitive-number-to-text obj))
    write     (prob (sexy-internal-primitive-number-to-text obj))
    print     (prob (sexy-internal-primitive-number-to-text obj))
    to-text   (prob (sexy-internal-primitive-number-to-text obj))
    to-bool   (prob (sexy-internal-primitive-not (= obj 0)))
    messages  (prob real-messages)
    answers?  (prob (prom (real-messages.has? msg)))
    autos     (prob '(to-number zero? pos? neg? abs floor ceil round truncate))
    resends   (prob ())
    default   idk
    to-number (prob obj)
    zero?     (prob (= obj 0))
    pos?      (prob (> obj 0))
    neg?      (prob (< obj 0))
    abs       (prob (sexy-internal-primitive-abs obj))
    floor     (prob (sexy-internal-primitive-floor obj))
    ceil      (prob (sexy-internal-primitive-ceil obj))
    round     (prob (sexy-internal-primitive-round obj))
    truncate  (prob (sexy-internal-primitive-truncate obj))
    abs       (prob (sexy-internal-primitive-abs obj))
))

(def rune-messages '(to-rune to-int code alpha? digit? whitespace? uc? lc? uc lc))

(def control-rune (:
    type      (prob 'rune)
    view      (prob (sexy-internal-primitive-list-to-text (list \\ obj)))
    write     (prob (sexy-internal-primitive-list-to-text (list \\ obj))) ; FIXME \space, \tab, \newline, \return
    print     (prob (sexy-internal-primitive-list-to-text (list obj)))
    to-text   (prob (sexy-internal-primitive-list-to-text (list obj)))
    to-bool   (prob (sexy-internal-primitive-not (sexy-internal-primitive-rune-whitespace? obj)))
    messages  (prob rune-messages)
    answers?  (prob (prom (rune-messages.has? msg)))
    autos     (prob rune-messages)
    resends   (prob ())
    default   idk
    to-rune   (prob obj)
    to-int    (prob (sexy-internal-primitive-text-to-number (sexy-internal-primitive-text obj)))
    code      (prob (sexy-internal-primitive-rune-to-int obj))
    alpha?       (prob (sexy-internal-primitive-rune-alpha? obj))
    digit?       (prob (sexy-internal-primitive-rune-digit? obj))
    whitespace?  (prob (sexy-internal-primitive-rune-whitespace? obj))
    uc?  (prob (sexy-internal-primitive-rune-uc? obj))
    lc?  (prob (sexy-internal-primitive-rune-lc? obj))
    uc   (prob (sexy-internal-primitive-rune-uc obj))
    lc   (prob (sexy-internal-primitive-rune-lc obj))
))

(def symbol-messages '(to-symbol))

(def control-symbol (:
    type      (prob 'symbol)
    view      (prob (sexy-internal-primitive-symbol-to-text obj))
    write     (prob (sexy-internal-primitive-symbol-to-text obj))
    print     (prob (sexy-internal-primitive-symbol-to-text obj))
    to-text   (prob (sexy-internal-primitive-symbol-to-text obj))
    to-bool   (prob true)
    messages  (prob symbol-messages)
    answers?  (prob (prom (symbol-messages.has? msg)))
    autos     (prob symbol-messages)
    resends   (prob ())
    default   idk
    to-symbol (prob obj)
))

(def bin-messages '(to-int to-list size clone set!))

(def control-bin (:
    ; FIXME
    type      (prob 'bin)
    view      (prob (sexy-internal-primitive-bin-to-text obj))
    write     (prob (sexy-internal-primitive-bin-to-text obj))
    print     (prob (sexy-internal-primitive-bin-to-text obj))
    to-text   (prob (sexy-internal-primitive-bin-to-text obj))
    to-bool   (prob true)
    messages  (prob bin-messages)
    answers?  (prob (prom (bin-messages.has? msg)))
    autos     (prob '(to-number to-list size clone))
    resends   (prob ())
    default   idk
    to-int    idk
    to-list   idk
    size      idk
    clone     idk
    set!      idk
))

(def text-messages '(to-symbol to-option to-number to-list to-bin to-stream size empty? clone chomp trim ltrim rtrim lpad rpad set! index take drop match split capture replace))

(def control-text (:
    type      (prob 'text)
    view      (prob (cat \" obj \"))
    write     (prob (cat \" obj \"))
    print     (prob obj)
    to-text   (prob obj)
    to-bool   (prob (if (= "" obj) false true))
    messages  (prob text-messages)
    answers?  (prob (prom (text-messages.has? msg)))
    autos     (prob text-messages) ; FIXME
    resends   (prob ())
    default   (prob
                 (prom 
                     (if (number? msg)
                         (if (> (sexy-internal-primitive-text-size obj) msg)
                             (sexy-internal-primitive-text-ref obj msg)
                             (error-object 'out-of-bounds %(send $obj $msg) "text: index out of bounds."))
                         ((idk obj) msg))))
    to-symbol   (prob (sexy-internal-primitive-text-to-symbol obj))
    to-option   (prob (sexy-internal-primitive-text-to-keyword obj))
    to-number   (prob (sexy-internal-primitive-text-to-number obj))
    to-list     (prob (sexy-internal-primitive-text-to-list obj))
    to-bin      (prob (sexy-internal-primitive-text-to-bin obj))
    to-stream   (prob (sexy-internal-primitive-text-to-stream obj))
    size    (prob (sexy-internal-primitive-text-size obj))
    empty?  (prob (= "" obj))
    clone   (prob (sexy-internal-primitive-text-clone obj))
    chomp   (prob (sexy-internal-primitive-text-chomp obj))
    trim    (prob (sexy-internal-primitive-text-trim obj))
    ltrim   (prob (sexy-internal-primitive-text-trim-left obj))
    rtrim   (prob (sexy-internal-primitive-text-trim-right obj))
    lpad    (prob (λ (rune n) (sexy-internal-primitive-text-pad-left obj rune n)))
    rpad    (prob (λ (rune n) (sexy-internal-primitive-text-pad-right obj rune n)))
    set!    (prob (λ (n rune) (sexy-internal-primitive-text-set! obj n rune)))
    index   (prob (λ (substr) (sexy-internal-primitive-text-subtext-index obj substr)))
    take    (prob (λ (n) (sexy-internal-primitive-text-take obj n)))
    drop    (prob (λ (n) (sexy-internal-primitive-text-drop obj n)))
    match (prob
        (proc (regex)
            (def flags (or opt.flags ""))
            (sexy-internal-primitive-text-match obj regex flags)))
    split (prob
        (proc (regex)
            (def flags (or opt.flags ""))
            (sexy-internal-primitive-text-split obj regex flags)))
    capture (prob
        (proc (regex)
            (def flags (or opt.flags ""))
            (sexy-internal-primitive-text-capture obj regex flags)))
    replace (prob
        (proc (regex replacement)
            (def flags (or opt.flags ""))
            (sexy-internal-primitive-text-replace obj regex flags)))
))

(def env-messages
    '(mama to-list to-record empty? size empty? clone def! has? get set! del! lookup lookup-list extend partition expand eval))

(def control-env (:
    type      (prob 'env)
    view      (prob (sexy-internal-primitive-env-to-text obj))
    write     (prob (sexy-internal-primitive-env-to-text obj))
    print     (prob (sexy-internal-primitive-env-to-text obj))
    to-text   (prob (sexy-internal-primitive-env-to-text obj))
    to-bool   (prob true)
    messages  (prob env-messages)
    answers?  (prob (prom (env-messages.has? msg)))
    autos     (prob '(empty? mama to-list to-record))
    resends   (prob ())
    default   idk
    mama      (prob (sexy-internal-primitive-env-mama obj))
    to-list   (prob (sexy-internal-primitive-env-to-list obj))
    to-record (prob (sexy-internal-primitive-env-to-record obj))
    empty?    (prob (= 0 (sexy-internal-primitive-env-size obj)))
    def!      (prob (sexy-internal-primitive-env-def! obj))   ; local
    get       (prob (sexy-internal-primitive-env-get obj))    ; local
    set!      (prob (sexy-internal-primitive-env-set! obj))   ; local or ancestral
    has?      (prob (sexy-internal-primitive-env-has? obj))   ; local
    del!      (prob (sexy-internal-primitive-env-del! obj))   ; local or ancestral
    lookup    (prob (sexy-internal-primitive-env-lookup obj)) ; local or ancestral
    lookup-list  (prob (sexy-internal-primitive-env-lookup-list obj)) ; local or ancestral
    extend       (prob (sexy-internal-primitive-env-extend obj))
    partition    (prob (sexy-internal-primitive-env-partition obj))
    seal! ; FIXME
    wild! ; FIXME
    expand    (prob 
        ; FIXME : macroexpand expr
    )
    eval      (prob
        ; FIXME : expand then interpret expr
    )
))

(def pair-messages
    '(head key tail val to-list to-vector to-record size empty? reverse cons has? append take drop apply fold reduce map filter sort each))

(def control-pair (:
    type      (prob 'pair)
    view      (prob (sexy-internal-primitive-pair-write obj))
    write     (prob (sexy-internal-primitive-pair-write obj))
    print     (prob (sexy-internal-primitive-pair-write obj))
    to-text   (prob (sexy-internal-primitive-pair-to-text obj)) ; all members must be runes
    to-bool   (prob (if (= () obj) false true))
    messages  (prob pair-messages)
    answers?  (prob (prom (pair-messages.has? msg)))
    autos     (prob '(head key tail val to-list to-vector to-record size empty? reverse))
    resends   (prob ())
    default   (prob
                (prom
                    (if (= (sexy-internal-get-object-type msg) 'int)
                        (sexy-internal-primitive-list-ref obj msg)
                        (idk))))
    head      (prob (sexy-internal-primitive-pair-head obj))
    key       (prob (sexy-internal-primitive-pair-head obj))
    car       (prob (sexy-internal-primitive-pair-head obj))
    tail      (prob (sexy-internal-primitive-pair-tail obj))
    val       (prob (sexy-internal-primitive-pair-tail obj))
    cdr       (prob (sexy-internal-primitive-pair-tail obj))
    to-list   (prob
                (if (sexy-internal-primitive-list? obj)
                    obj
                    (sexy-internal-primitive-list
                        (sexy-internal-primitive-pair-head obj)
                        (sexy-internal-primitive-pair-tail obj))))
    to-vector (prob (sexy-internal-primitive-pair-to-vector obj))
    to-record (prob (sexy-internal-primitive-pair-to-record obj))
    size      (prob (sexy-internal-primitive-pair-size obj))
    empty?    (prob (if (= obj ()) true false))
    reverse   (prob (sexy-internal-primitive-pair-reverse obj))
    cons      (prob
                (proc (item)
                    (sexy-internal-primitive-pair item obj)))
    has?      (prob
                (proc (item)
                    (sexy-internal-primitive-pair-has? obj item)))
    append
    take      (prob
                (proc (n)
                    (sexy-internal-primitive-pair-take obj n)))
    drop      (prob
                (proc (n)
                    (sexy-internal-primitive-pair-drop obj n)))
    apply     (prob
                (λ (args options)
                    (if (!= (sexy-internal-primitive-pair-size args) 1)
                        (error-object 'arg-error %(list.apply args opts) "List apply takes only one integer argument.")
                        (sexy-internal-primitive-list-ref obj (sexy-internal-primitive-pair-head args)))))
    fold      (prob
                (λ (acc funk)
                    (if obj.empty?
                        acc
                        (obj.tail.fold (funk acc obj.head) funk))))
    reduce    (prob
                 (λ (acc funk)
                     (if obj.empty?
                         acc
                         (funk obj.head (obj.tail.reduce acc funk)))))
    map       (prob
                 (λ (funk)
                     (obj.reduce () (λ (x y) (pair (funk x) y)))))
    filter    (prob
                 (λ (funk)
                     (obj.reduce () (λ (x y) (if (funk x) (pair x y) y)))))
    sort      (prob
                 (λ (funk)
                     (def merge (λ (a b)
                         (if a.size.zero?
                             b
                             (if b.size.zero?
                                 a
                                 (if (funk a.head b.head)
                                     (pair a.0 (merge a.tail b))
                                     (pair b.0 (merge a b.tail)))))))
                     (def sort (λ (yarr)
                         (def len yarr.size)
                         (if (< len 2)
                             yarr
                             (seq
                                 (def half (send (/ len 2) 'floor))
                                 (merge (sort (yarr.take half)) (sort (yarr.drop half)))))))
                     (sort obj)))
    each      (prob
                 (λ (funk)
                     (if xs.empty?
                         null
                         (seq
                             (funk xs.head)
                             (xs.tail.each funk)))))
))

(def vector-messages
    '())

(def control-vector (:

))

(def record-messages
    '(to-list to-record size empty? keys values pairs clone get put rm set! del! has? apply merge fold reduce map filter sort each))

(def control-record (:
    type      (prob 'record)
    view      (prob (sexy-internal-primitive-record-to-text obj))
    write     (prob (sexy-internal-primitive-record-to-text obj))
    print     (prob (sexy-internal-primitive-record-to-text obj))
    to-text   (prob (sexy-internal-primitive-record-to-text obj))
    to-bool   (prob (if (= 0 sexy-internal-primitive-record-size obj) false true))
    messages  (prob record-messages)
    answers?  (prob (prom (record-messages.has? msg)))
    autos     (prob '(size keys values pairs clone to-list to-record))
    resends   (prob ())
    default   (prob
                (prom
                    (if (sexy-internal-primitive-record-has? obj msg)
                        (sexy-internal-primitive-record-has? obj msg)
                        null)))
    to-list   (prob (sexy-internal-primitive-record-to-list obj))
    to-record (prob obj)
    size      (prob (sexy-internal-primitive-record-size obj))
    empty?    (prob (= 0 (sexy-internal-primitive-record-size obj)))
    keys      (prob (sexy-internal-primitive-record-keys obj))
    values    (prob (sexy-internal-primitive-record-values obj))
    pairs     (prob (sexy-internal-primitive-record-to-list obj))
    clone     (prob (sexy-internal-primitive-record-clone obj))
    get       (prob (proc (k) (sexy-internal-primitive-record-get obj k)))
    put       (prob (proc () (sexy-internal-primitive-record-put obj rest)))
    rm        (prob (proc () (sexy-internal-primitive-record-rm obj rest)))
    set!      (prob (proc () (sexy-internal-primitive-record-set! obj rest)))
    del!      (prob (proc () (sexy-internal-primitive-record-del! obj rest)))
    has?      (prob (proc (k) (sexy-internal-primitive-record-has? obj k)))
    merge     (prob (proc (other) (sexy-internal-primitive-record-merge obj other)))
    apply     (prob
                (λ (args options)
                    (if (!= (sexy-internal-primitive-pair-size args) 1)
                        (error-object 'arg-error %(record.apply $args $options) "Record apply takes only one argument.")
                        (sexy-internal-primitive-record-get obj args.head))))
    fold      (prob
                (def xs obj.to-list)
                (λ (acc funk)
                    (if xs.empty?
                        acc
                        (xs.tail.fold (funk acc xs.head) funk))))
    reduce    (prob
                (def xs obj.to-list)
                (λ (acc funk)
                    (if xs.empty?
                        acc
                        (funk xs.head (xs.tail.reduce acc funk)))))
    map       (prob
                (def noob (record))
                (def ps obj.pairs)
                (λ (funk)
                    (ps.each (λ (p) (noob.set! p.head (funk p))))))
    filter    (prob
                (def noob (record))
                (def ps obj.pairs)
                (λ (funk)
                    (ps.each (λ (p) (if (funk p) (noob.set! p.head p.tail) null)))))
    each      (prob
                (λ (funk)
                    (obj.to-list.each funk)))
))

(def proc-messages '(apply arity code env formals))

(def control-λ (:
    type      (prob 'λ)
    view      (prob (sexy-internal-primitive-λ-to-text obj))
    write     (prob (sexy-internal-primitive-λ-to-text obj))
    print     (prob (sexy-internal-primitive-λ-to-text obj))
    to-text   (prob (sexy-internal-primitive-λ-to-text obj))
    to-bool   (prob true)
    messages  (prob proc-messages)
    answers?  (prob (prom (proc-messages.has? msg)))
    autos     (prob '(arity code env formals))
    resends   (prob ())
    default   idk
    apply     (prob (λ (args opts) (sexy-internal-primitive-apply obj args opts)))
    arity     (prob (sexy-internal-primitive-proc-arity obj))
    code      (prob (sexy-internal-primitive-proc-code obj))
    env       (prob (sexy-internal-primitive-proc-env obj))
    formals   (prob (sexy-internal-primitive-proc-formals obj))
))

(def control-proc (:
    type      (prob 'proc)
    view      (prob (sexy-internal-primitive-proc-to-text obj))
    write     (prob (sexy-internal-primitive-proc-to-text obj))
    print     (prob (sexy-internal-primitive-proc-to-text obj))
    to-text   (prob (sexy-internal-primitive-proc-to-text obj))
    to-bool   (prob true)
    messages  (prob proc-messages)
    answers?  (prob (prom (proc-messages.has? msg)))
    autos     (prob '(arity code env formals))
    resends   (prob ())
    default   idk
    apply     (prob (λ (args opts) (sexy-internal-primitive-apply obj args opts)))
    arity     (prob (sexy-internal-primitive-proc-arity obj))
    code      (prob (sexy-internal-primitive-proc-code obj))
    env       (prob (sexy-internal-primitive-proc-env obj))
    formals   (prob (sexy-internal-primitive-proc-formals obj))
))

(def control-operator (:
    type      (prob 'operator)
    view      (prob (sexy-internal-primitive-operator-to-text obj))
    write     (prob (sexy-internal-primitive-operator-to-text obj))
    print     (prob (sexy-internal-primitive-operator-to-text obj))
    to-text   (prob (sexy-internal-primitive-operator-to-text obj))
    to-bool   (prob true)
    messages  (prob proc-messages)
    answers?  (prob (prom (proc-messages.has? msg)))
    autos     (prob '(arity code env formals))
    resends   (prob ())
    default   idk
    apply     (prob (λ (args opts) (sexy-internal-primitive-apply obj args opts)))
    arity     (prob (sexy-internal-primitive-proc-arity obj))
    code      (prob (sexy-internal-primitive-proc-code obj))
    env       (prob (sexy-internal-primitive-proc-env obj))
    formals   (prob (sexy-internal-primitive-proc-formals obj))
))

(def stream-messages
    '())

(def control-stream (:

))

(def fs-socket-messages
    '())

(def control-fs-socket (:

))

(def tcp-socket-messages
    '())

(def control-tcp-socket (:

))

(def control-eof (:
    type      (prob 'EOF)
    view      (prob "EOF")
    write     (prob "EOF")
    print     (prob "EOF")
    to-text   (prob "END OF LINE.")
    to-bool   (prob false)
    messages  (prob proc-messages)
    answers?  (prob (prom (proc-messages.has? msg)))
    autos     (prob '(arity code env formals))
    resends   (prob ())
    default   idk
))

(def control (:
    null         control-null
    bool         control-bool
    int          control-int
    rational     control-rat
    real         control-real
    rune         control-rune
    symbol       control-symbol
    bin          control-bin
    text         control-text
    environment  control-env
    pair         control-pair
    vector       control-vector
    record       control-record
    λ            control-λ
    proc         control-proc
    operator     control-operator
    stream       control-stream
    fs-socket    control-fs-socket
    tcp-socket   control-tcp-socket
    EOF          control-eof
))

(def object-defaults (:
    type    (λ (obj) 'object)
    view    (λ (obj) %(object: @(send obj 'messages)))
    write   (λ (obj) %(object: @(send obj 'messages)))
    print   (λ (obj) %(object: @(send obj 'messages)))
    to-bool (λ (obj) true)
))

(proc has-msg? (obj msg)
    ((sexy-internal-object-answers? obj) msg))

(proc autofire (obj msg def-thunk)
    (if (has-msg? obj msg)
        (let (method (sexy-internal-object-get-message obj msg))
            (if (sexy-internal-list-has? (sexy-internal-object-autos obj) msg)
                (method)
                method))
        (def-thunk)))

(proc sender (obj msg)
    (def t (sexy-internal-get-object-type obj))
    (if (sexy-internal-record-has? control t)
        (let (dispatcher (sexy-internal-record-get control t))
            (if (sexy-internal-record-has? dispatcher msg)
                ((sexy-internal-record-get dispatcher msg) obj)
                (((sexy-internal-record-get dispatcher 'default) obj) msg)))
        (case msg
            ; begin with unshadowable reflection messages
            (answers?)
                (sexy-internal-object-answers? obj)
            (autos)
                (sexy-internal-object-autos obj)
            (default)
                (sexy-internal-object-default obj)
            (messages)
                (sexy-internal-object-messages obj)
            (resends)
                (sexy-internal-object-resends obj)
            ; end reflection; begin shadowable messages with defaults
            (type view write print to-bool)
                (autofire obj msg (λ () ((object-defaults msg) obj)))
            ; regular messages
            default: 
                (autofire obj msg (λ () ((sexy-internal-object-default obj) msg))))))


(rem:
"

vector

view
to-bool -> (#) is false, else true
to-text -> all items must be runes
to-list
to-vector
to-record
size
empty?
clone
pairs
(has? item)
(index item) -> n or null
(put n v n v n v)   ; functional
(set! n v n v n v)  ; imperative
(append x)
(take n)
(drop n)
(apply (n) null)
(fold init proc)
(reduce init proc)
(map proc)
(filter proc)
(sort op)
(each proc)


stream

view
to-bool
input?
output?
open?
close

source

view
to-bool -> open?
to-text -> printable
ready?
read
read-rune
peek-rune
read-line
read-lines -> to-list
read-text -> slurp
read-sexy -> all sexy forms to list
(assert-rune "runes")
(skip n)
(skip-while "runes")
(skip-until "runes")
(read-tokens n)
(read-token-while "runes")
(read-token-until "runes")
(read-token-if proc)
(each proc) ?

sink

flush
nl -> newline
(write obj) -> obj.view
(print obj) -> obj.to-text
(say obj)   -> obj.print + obj.nl


fs-socket

to-bool -> true
ready? -> true if there is a connection ready to be accepted
accept -> accepts a connection and returns a socket
close -> shut down the TCP listener
path -> returns the file system path of the listener

socket messages

to-bool -> true
close -> close the socket
path -> file system path the socket is connected to


tcp-socket

to-bool -> true
ready? -> true if there is a connection ready to be accepted
accept -> accepts a connection and returns a socket
close -> shut down the TCP listener
ip -> returns local IP address
port -> returns the port number of the listener

socket messages

to-bool -> true
close -> close the socket
local-addr -> local IP address of the socket
local-port -> local port number of the socket
remote-addr -> remote IP address of the socket
remote-port -> remote port number of the socket
"
)


; 
; (define (sexy-send-vector obj msg cont err)
;     (define msgs '(view to-bool to-text to-list pairs size clone has? set! apply fold reduce map filter sort))
;     (define (vdefault msg)
;         (if (number? msg)
;             (if (> (vector-length obj) msg)
;                 (cont (vector-ref obj msg))
;                 (err (sexy-error-object 'out-of-bounds `(,obj ,msg) "vector: index out of bounds.") cont))
;             (idk obj msg cont err)))
;     (case msg
;         ((type view autos resends default to-bool to-text to-list pairs size clone has? set! apply messages responds?)
;             (cont 
;                 (case msg
;                     ((type) 'vector)
;                     ((view) (cons (string->keyword "vector") (map sexy-view (vector->list obj))))
;                     ((to-bool) (not (eq? (vector-length obj) 0)))
;                     ((to-list) (vector->list obj))
;                     ((to-text) (apply string (vector->list obj)))
;                     ((autos) '(view to-text to-bool to-list size pairs clone))
;                     ((resends) '())
;                     ((default) vdefault)
;                     ((pairs) (vector->list (vector-map (lambda (i x) (cons i x)) obj)))
;                     ((size) (vector-length obj))
;                     ((clone) (vector-copy obj))
;                     ((has?)
;                         (lambda (item)
;                             (if (vector-index
;                                     (lambda (x) (eq? x item))
;                                     obj)
;                                 #t
;                                 #f)))
;                     ((set!)
;                         (lambda (idx val)
;                             (if (> idx (vector-length obj))
;                                 (err (sexy-error-object 'out-of-bounds `(,obj ,msg) "vector: index out of bounds.") cont)
;                                 (begin
;                                     (vector-set! obj idx val)
;                                     obj))))
;                     ((messages) msgs)
;                     ((responds?)
;                         (lambda (msg)
;                             (or
;                                 (and (number? msg) (> (vector-length obj) msg))
;                                 (if (member msg msgs) #t #f))))
;                     ((apply)
;                         (sexy-proc
;                             primitive-type
;                             'pair
;                             (lambda (args opts cont err)
;                                 (sexy-send-vector obj (caar args) cont err)))))))
;         ((fold)
;             (sexy-ho
;                 '(λ (vec)
;                     (λ (acc funk)
;                         (vec.to-list.fold acc funk)))
;                 obj
;                 cont
;                 err))
;         ((reduce)
;             (sexy-ho
;                 '(λ (vec)
;                     (λ (acc funk)
;                         (vec.to-list.reduce acc funk)))
;                 obj
;                 cont
;                 err))
;         ((map)
;             (sexy-ho
;                 '(λ (vec)
;                     (λ (funk)
;                         (def mapped (vec.to-list.map funk))
;                         mapped.to-vector))
;                 obj
;                 cont
;                 err))
;         ((filter)
;             (sexy-ho
;                 '(λ (vec)
;                     (λ (funk)
;                         (def mapped (vec.to-list.filter funk))
;                         mapped.to-vector))
;                 obj
;                 cont
;                 err))
;         ((sort)
;             (sexy-ho
;                 '(λ (vec)
;                     (λ (funk)
;                         (def sorted (vec.to-list.sort funk))
;                         sorted.to-vector))
;                 obj
;                 cont
;                 err))
;         (else
;             (vdefault msg))))
; 
; (define (sexy-send-stream obj msg cont err)
;     (case msg
;         ((type view resends default to-text to-bool to-stream input? output? open? resends default)
;             (cont 
;                 (case msg
;                     ((type) 'stream)
;                     ((view to-text) obj)
;                     ((to-bool) #t)
;                     ((to-stream) obj)
;                     ((resends) '())
;                     ((default) (cont default-default))
;                     ((input?) (input-port? obj))
;                     ((output?) (output-port? obj))
;                     ((open?) (not (port-closed? obj))))))
;         (else
;             (if (input-port? obj)
;                 (sexy-send-input-stream obj msg cont err) 
;                 (sexy-send-output-stream obj msg cont err)))))
; 
; (define (sexy-send-input-stream obj msg cont err)
;     (define msgs
;         '(view to-bool input? output? open? close
;           ready? read read-rune peek-rune read-line read-text assert-rune skip skip-while skip-until
;           read-token read-token-while read-token-until read-token-if to-list to-text read-sexy))
;     (case msg
;         ((ready? autos read read-rune peek-rune read-line read-text assert-rune skip skip-while skip-until
;           read-token read-token-while read-token-until read-token-if to-list to-text read-sexy
;           messages responds?)
;             (if (port-closed? obj)
;                 (err (sexy-error-object 'input-stream-closed `(send ,obj ,msg) "Input stream closed.") cont)
;                 (cont 
;                     (case msg
;                         ((autos) '(view to-text to-bool to-list ready? input? output? open? read read-rune peek-rune read-line read-text read-sexy)) 
;                         ((ready?) (char-ready? obj))
;                         ((read) (sexy-read obj))
;                         ((read-rune) (read-char obj))
;                         ((peek-rune) (peek-char obj))
;                         ((read-line) (read-line obj))
;                         ((read-text) (read-string #f obj))
;                         ((read-sexy) (sexy-read-file obj))
;                         ((assert-rune)
;                             (sexy-proc
;                                 primitive-type
;                                 'stream
;                                 (lambda (args opts cont err)
;                                     (if (not (= 1 (length args)))
;                                         (err (sexy-error-object 'arity `assert-rune "stream.assert-rune requires one text argument") cont)
;                                         (let ((runes (string->list (car args))))
;                                             (define next (read-char obj))
;                                             (if (member next runes)
;                                                 (cont next)
;                                                 (err (sexy-error-object 'assert-rune-FAIL `(assert-rune next ,(car args)) "Assertion FAIL") cont)))))))
;                         ((skip)
;                             (lambda (n)
;                                 (read-string n obj)
;                                 'null))
;                         ((skip-while)
;                             (lambda (s)
;                                 (define runes (string->list s))
;                                 (let loop ((tok (peek-char obj)))
;                                     (if (member tok runes)
;                                         (begin
;                                             (read-char obj)
;                                             (loop (peek-char obj)))
;                                         'null))))
;                         ((skip-until)
;                             (lambda (s)
;                                 (define runes (string->list s))
;                                 (let loop ((tok (peek-char obj)))
;                                     (if (member tok runes)
;                                         'null
;                                         (begin
;                                             (read-char obj)
;                                             (loop (peek-char obj)))))))
;                         ((read-token read-tokens)
;                             (lambda (n)
;                                 (read-string n obj)))
;                         ((read-token-while)
;                             (lambda (s)
;                                 (define runes (string->list s))
;                                 (let loop ((tok (peek-char obj)) (acc '()))
;                                     (if (member tok runes)
;                                         (let ((t (read-char obj)))
;                                             (loop (peek-char obj) (cons t acc)))
;                                         (list->string (reverse acc))))))
;                         ((read-token-until)
;                             (lambda (s)
;                                 (define runes (string->list s))
;                                 (let loop ((tok (peek-char obj)) (acc '()))
;                                     (if (member tok runes)
;                                         (list->string (reverse acc))
;                                         (let ((t (read-char obj)))
;                                             (loop (peek-char obj) (cons t acc)))))))
;                         ((read-token-if)
;                             (sexy-proc
;                                 primitive-type
;                                 'env
;                                 (lambda (args opts cont err)
;                                     (if (not (= 1 (length args)))
;                                         (err (sexy-error-object 'arity `(read-token-if) "read-token-if: requires one proc argument.") cont)
;                                         (let ((pred (car args)))
;                                             (let loop ((tok (peek-char obj)) (acc '()))
;                                                 (sexy-apply
;                                                     pred
;                                                     (list tok)
;                                                     'null
;                                                     (lambda (rv)
;                                                         (sexy-bool
;                                                             rv
;                                                             (lambda (ok)
;                                                                 (if ok
;                                                                     (let ((t (read-char obj)))
;                                                                         (loop (peek-char obj) (cons t acc)))
;                                                                     (cont (list->string (reverse acc)))))
;                                                             err))
;                                                     err)))))))
;                         ((messages) msgs)
;                         ((responds?)
;                             (lambda (msg)
;                                 (if (member msg msgs) #t #f)))
;                         ((to-list read-lines) (read-lines obj))))))
;         ((close) (close-input-port obj) (cont 'null))
;         (else (idk msg obj cont err))))
; 
; (define (sexy-send-output-stream obj msg cont err)
;     (define msgs
;         '(view to-text to-bool input? output? open? write print say nl flush close))
;     (case msg
;         ((write print say nl autos)
;             (if (port-closed? obj)
;                 (err (sexy-error-object 'output-stream-closed `(send ,obj ,msg) "Output stream closed.") cont)
;                 (cont
;                     (case msg
;                         ((autos) '(view to-text to-bool ready? input? output? open? nl close)) 
;                         ((write)
;                             (lambda (x)
;                                 (sexy-write x obj)
;                                 'null))
;                         ((print)
;                             (lambda (x)
;                                 (sexy-print x obj)
;                                 'null))
;                         ((say)
;                             (lambda (x)
;                                 (sexy-print x obj)
;                                 (newline obj)
;                                 'null))
;                         ((nl) (newline obj) 'null)))))
;         ((messages) (cont msgs))
;         ((responds?)
;             (cont
;                 (lambda (msg)
;                     (if (member msg msgs) #t #f))))
;         ((flush) (flush-output obj) (cont 'null))
;         ((close) (close-output-port obj) (cont 'null))
;         (else (idk msg obj cont err))))
; 

