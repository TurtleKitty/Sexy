
(def log null)

(lib (sys-log)
    (set! log sys-log)
    check-sexy-syntax)


(proc check-sexy-syntax (prog)
    (proc checky (form forms)
        (proc go-on (ok)
            (if (not ok)
                false
                (if (= forms ())
                    ok
                    (checky forms.head forms.tail))))
        (if (list? form)
            (if (= form ())
                (go-on true)
                (go-on
                    (let (head form.head)
                        (case head
                            (def)      (check-sexy-def form)
                            (quote)    (check-sexy-quote form)
                            (if)       (check-sexy-if form)
                            (seq)      (check-sexy-seq form)
                            (set!)     (check-sexy-set! form)
                            (位)        (check-sexy-lambda form)
                            (proc)     (check-sexy-proc form)
                            (wall)     (check-sexy-wall form)
                            (gate)     (check-sexy-gate form)
                            (capture)  (check-sexy-capture form)
                            (guard)    (check-sexy-guard form)
                            (fail)     (check-sexy-fail form)
                            (ensure)   (check-sexy-ensure form)
                            (load)     (check-sexy-load form)
                            (syntax)   (check-sexy-syntax-export form)
                            default:   true))))
            (go-on true)))
    (if (and (pair? prog) (list? prog))
        (let (first prog.head)
            (if (and (pair? first) (= 'modules first.head))
                (checky prog.1 prog.tail.tail) ; skip (modules)
                (checky first prog.tail)))
        true))

(proc syntax-error (code e usage)
    (log "Syntax error:")
    (log code)
    (log e)
    (log usage)
    (log "") ; newline
    false)

(proc blasphemy (name)
    (cat with: " " "The name" $" name.to-symbol $" "is sacred.  It cannot be redefined."))

(proc check-sexy-def (code)
    (def usage "(def <name> <value>)")
    (def name code.1)
    (cond
        (not (symbol? name))
            (syntax-error code "def requires a symbol as its first argument." usage)
        (< code.size 3)
            (syntax-error code "def: too few arguments" usage)
        (> code.size 3)
            (syntax-error code "def: too many arguments" usage)
        (global? name)
            (syntax-error code (cat "def: " (blasphemy name)) usage)
        default: true))

(proc check-sexy-quote (code)
    (def usage "(quote <s-expression>)")
    (if (!= 2 code.size)
        (syntax-error code "quote takes one argument." usage)
        true))

(proc check-sexy-if (code)
    (def usage "(if <predicate> <consequent> <alternative>)")
    (if (< code.size 4)
        (syntax-error code "if: too few arguments" usage)
        (if (> code.size 4)
            (syntax-error code "if: too many arguments" usage)
            true)))

(proc check-sexy-seq (code)
    (def usage "(seq <form> ...)")
    (if (< code.size 2)
        (syntax-error code "seq: empty sequences are forbidden." usage)
        true))

(proc check-sexy-set! (code)
    (def usage "(set! <name> <value>)")
    (def name code.1)
    (cond
        (not (symbol? name))
            (syntax-error code "set! requires a symbol as its first argument." usage)
        (< code.size 3)
            (syntax-error code "set!: too few arguments" usage)
        (> code.size 3)
            (syntax-error code "set!: too many arguments" usage)
        (global? name)
            (syntax-error code (cat "set!: " (blasphemy name)) usage)
        default: true))

(proc check-sexy-macro (code)
    (def usage "(macro <name> (<arg> ...) <body> ...)")
    (def name code.1)
    (cond
        (not (symbol? code.1))
            (syntax-error code "macro requires a symbol as its first argument." usage)
        (not (list? code.2))
            (syntax-error code "macro: second argument must be a list of formal parameters." usage)
        (< code.size 4)
            (syntax-error code "macro: at least one body form is required." usage)
        (global? name)
            (syntax-error code (cat "macro: " (blasphemy name)) usage)
        default: true))

(proc check-sexy-lambda (code)
    (def usage "(位 (<arg> ...) <body>)")
    (if (not (list? code.1))
        (syntax-error code "位: second argument must be a list of formal parameters." usage)
        (if (!= code.size 3)
            (syntax-error code "位: one body form is required; only one is allowed." usage)
            true)))

(proc check-sexy-proc (code)
    (def usage "(proc <name?> (<arg> ...) <body> ...)")
    (if (symbol? code.1)
        (let (name code.1 args code.2)
            (if (not (list? args))
                (syntax-error code "named proc: third argument must be a list of formal parameters." usage)
                (if (< code.size 4)
                    (syntax-error code "proc: at least one body form is required." usage)
                    true)))
        (let (args code.1)
            (if (not (list? args))
                (syntax-error code "anon proc: second argument must be a list of formal parameters." usage)
                (if (< code.size 3)
                    (syntax-error code "proc: at least one body form is required." usage)
                    true)))))

(proc check-sexy-wall (code)
    (def usage "(wall (<arg> ...) <body> ...)")
    (if (< code.size 3)
        (syntax-error code "wall: at least one body form is required." usage)
        (if (not (pair? code.1))
            (syntax-error code "wall: second argument must be a list of parameters to pass." usage)
            true)))

(proc check-sexy-gate (code)
    (def usage "(gate <body> ...)")
    (if (< code.size 2)
        (syntax-error code "gate: too few arguments." usage)
        true))

(proc check-sexy-capture (code)
    (def usage "(capture <name> <body> ...)")
    (if (< code.size 3)
        (syntax-error code "capture: too few arguments." usage)
        (if (not (symbol? code.1))
            (syntax-error code "capture requires a symbol as its first argument." usage)
            true)))

(proc check-sexy-guard (code)
    (def usage "(guard (proc (error restart) <body> ...) <body> ...)")
    (if (< code.size 3)
        (syntax-error code "guard: too few arguments." usage)
        true))
        
(proc check-sexy-fail (code)
    (def usage "(fail <object>)")
    (if (< code.size 2)
        (syntax-error code "fail: too few arguments." usage)
        (if (> code.size 2)
            (syntax-error code "fail: too many arguments." usage)
            true)))

(proc check-sexy-ensure (code)
    (def usage "(ensure <thunk> <body> ...)")
    (if (< code.size 3)
        (syntax-error code "ensure: too few arguments." usage)
        true))

(proc check-sexy-load (code)
    (def usage "(load <symbol-or-text-path> <arg> ...)")
    (if (< code.size 2)
        (syntax-error code "load: too few arguments." usage)
        (let (uri code.1)
            (if (not (or (symbol? uri) (text? uri)))
                (syntax-error code "load: first argument must be a symbol or text." usage)
                true))))

(proc check-sexy-syntax-export (code)
    (def usage "(syntax <name> <operator> ...)")
    (if (= (mod code.size 2) 0)
        (syntax-error code "syntax: must have an even number of arguments." usage)
        (let loop (x code.head xs code.tail)
            (if (not (symbol? x))
                (syntax-error code "syntax: exported names must be symbols." usage)
                (if xs
                    (loop xs.head xs.tail)
                    true)))))

