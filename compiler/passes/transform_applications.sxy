
(use gen-pass "generic.sxy")

(lib () pass)

; (<λ|proc> x y foo: 1 z bar: 2 ...) -> (<λ|proc> (x y z) (record 'foo 1 'bar 2))

;   (λ id (x y z) expr) ->
;       (λ id (args-gensym opt-gensym)
;           (if (= (arity (send (args-gensym 'size) null)) null)
;               (seq
;                   ((send (env 'def!) null) ('x args-gensym.0 'y args-gensym.1 'z args-gensym.2) null)
;                   expr)
;               (error (object ('type 'error 'name 'arity 'form '(λ (x y z) expr)
;                               'to-text (cat "Procedure requires " arity " arguments; given " args-gensym))
;                                null))))

;   (proc id (x y z) ...) ->
;       (λ id (args-gensym opt)
;           (if (< (arity (send (args-gensym 'size) null)) null)
;               (seq
;                   ((send (env 'def!) null) ('x args-gensym.0 'y args-gensym.1 'z args-gensym.2 'rest args-gensym.tail.tail.tail) null)
;                   expr)
;               (error (object ('type 'error 'name 'arity 'form '(proc (x y z) ...)
;                               'to-text (cat "Procedure requires at least " arity " arguments; given " args-gensym))
;                                null))))

(proc pass (form)
    (if (pair? form)
        (case form.head
            (if quote wall gate guard error)
                ((gen-pass form.head) pass form)
            (seq capture)
                %($form.head @(form.tail.map pass))
            (λ)
                (let (args (gensym "args") no-opt (gensym "opt") arity form.2.size)
                    %(λ $form.1 ($args $no-opt)
                        (if (= ($arity (send (list $args 'size) null)) null)
                            (seq
                                ((send (env 'def!) null) $(zip (form.2.map (_ (list 'quote _))) args) null)
                                $(pass form.3))
                            (error (object ('type 'error 'name 'arity 'form '(λ $form.2 $form.3)
                                           'to-text (cat "Procedure requires " $arity " arguments; given " $args))
                                            null)))))
            (proc)
                %(proc $form.1 $(pair 'opt form.2) @(form.tail.tail.tail.map pass))
            default:
                (let (the-head (pass form.head))
                    (if (pair? form.tail)
                        (let (the-tail (form.tail.map pass))
                            (let loop (x the-tail.head xs the-tail.tail args () options ())
                                (if (option? x)
                                    (let (opts (pair xs.head (pair %(quote $x.to-symbol) options)))
                                        (if (pair? xs.tail)
                                            (loop xs.1 xs.tail.tail args opts)
                                            %($the-head $(pair 'record opts.reverse) @args.reverse)))
                                    (let (yarrrgs (pair x args))
                                        (if (pair? xs)
                                            (loop xs.head xs.tail yarrrgs options)
                                            %($the-head $(if options (pair 'record @options.reverse) 'null) @yarrrgs.reverse))))))
                        %($the-head null))))
        form))

