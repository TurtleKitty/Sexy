
(use gen-pass "generic.sxy")

(lib () pass)

(proc pass (form)
    (cps form))

(proc atomic? (form)
    (if (pair? form)
        ((send '(quote proc λ) 'has?) form.head)
        true))

(proc gencont ()
    (gensym "continuation"))

(proc genhand ()
    (gensym "handler"))

(proc genval ()
    (gensym "value"))

(proc error-object (name form text)
    (error (object 'name name 'form form 'to-text text)))

(proc cps-frag (cont hand body)
    %(λ (env $cont $hand) $body))

(proc cps (form)
    (if (and (pair? form) (list? form))
        (case form.head
            (quote)    (cps-quote form)
            (if)       (cps-if form)
            (seq)      (cps-seq form)
            (λ proc)   (cps-lambda form)
            (wall)     (cps-wall form)
            (gate)     (cps-gate form)
            (capture)  (cps-capture form)
            (guard)    (cps-guard form)
            (error)    (cps-error form)
            (load)     (cps-load form)
            default:   (cps-application form))
        (cps-atom form)))

(proc cps-quote (form)
    (def cont (gencont))
    (def hand (genhand))
    (cps-frag
        cont
        hand
        %($cont $form.1)))

(proc cps-if (form)
    (def pred (cps form.1))
    (def if-true (cps form.2))
    (def if-false (cps form.3))
    (def cont (gencont))
    (def hand (genhand))
    (def pred-val (genval))
    (def bool (genval))
    (cps-frag
        cont
        hand
        %($pred
            env
            (λ ($pred-val)
                (send
                    (λ ($bool)
                        (if $bool
                            ($if-true  env $cont $hand)
                            ($if-false env $cont $hand)))
                    $hand
                    null
                    $pred-val
                    'to-bool))
            $hand)))

(proc cps-seq (form)
    ; all seqs should be binary by now
    (def cps-head (cps xs.head))
    (def cps-tail (cps xs.tail))
    (def cont (gencont))
    (def hand (genhand))
    (cps-frag
        cont
        hand
        %($cps-head
            env
            (λ () ($cps-tail env $cont $hand))
            $hand)))

(proc cps-lambda (form)
    ; strip ids as well
    (def cont (gencont))
    (def hand (genhand))
    (def lambda-cont (gencont))
    (def lambda-hand (genhand))
    (def new-args (pair lambda-cont (pair lambda-hand form.2)))
    (cps-frag
        cont
        hand
        %($cont (λ $new-args @form.tail.tail.tail))))

(proc cps-wall (form)
    (def cont (gencont))
    (def hand (genhand))
    (def noob (genval))
    (def looker (genval))
    (def vals (genval))
    (def args form.1)
    (def cps-body (cps form.tail.tail))
    (cps-frag
        cont
        hand
        %(send
            (λ ($looker)
                ($looker
                    (λ ($vals)
                        (environment
                            (λ ($noob) ($cps-body $noob $cont $hand))
                            $hand
                            null
                            @(flatten (zip (quote $args) $vals))))
                    $hand
                    null
                    $args))
            $hand
            env
            'lookup-list)))

(proc (cps-gate form)
    (def cps-body (cps form.tail))
    (def cont (gencont))
    (def hand (genhand))
    (cps-frag
        cont
        hand
        %($cont
            (cps-body env identity $hand))))

(proc cps-atom (form)
    (def cont (gencont))
    (def hand (genhand))
    (def pass (cps-frag cont hand %($cont $form)))
    (if (symbol? form)
        (if (option? form)
            (error-object 'misplaced-option form "All options should be erased by now!")
            (case form
                (true false null env) pass
                default:
                    (if (global? form)
                        (cps-frag
                            cont
                            hand
                            (let (v (genval))
                                %($cont (send (λ ($v) ($cont $v)) hand null global 'lookup))))
                        (cps-frag
                            cont
                            hand
                            (let (v (genval))
                                %($cont (send (λ ($v) ($cont $v)) hand null env 'lookup)))))))
        pass))


(rem:

(define (cps-capture form)
    (define name (cadr form))
    (define lamb (cons 'proc (cons (list name) (cddr form))))
    (define lamb-c (cps lamb))
    (frag
        (lamb-c
            env
            (lambda (funk)
                (sexy-apply
                    funk
                    (list (lambda (k-val) (cont k-val)))
                    'null
                    top-cont
                    err))
            err)))

(define (cps-guard form)
    (define handler (cadr form))
    (define exprs (cddr form))
    (define handler-c (cps handler))
    (define expr-c (sexy-seq-subcontractor exprs #t))
    (frag
        (handler-c
            env
            (lambda (handler-fn)
                (define (new-err-cont e k)
                    (sexy-apply handler-fn (list e k) 'null cont err))
                (expr-c env cont new-err-cont))
            err)))

(define (cps-error form)
    (define errobj (cadr form))
    (define erob-c (cps errobj))
    (frag
        (erob-c
            env
            (lambda (e)
                (err e cont))
            err)))

(define (cps-load form)
    (define path (cadr form))
    (define module (if (hte? sexy-modules path) (htr sexy-modules path) (lambda args 'null)))
    (define load-env (local-env))
    (define args-opts (prepare-sexy-args (cddr form)))
    (define args-c (cps-list (car args-opts)))
    (define opts-c (cps-list (cdr args-opts)))
    (frag 
        (args-c
            env
            (lambda (args)
                (opts-c
                    env
                    (lambda (opts)
                        (module load-env top-cont top-err)
                        (lookup load-env 'sexy-library-export-procedure
                            (lambda (exporter)
                                (if (eq? exporter not-found)
                                    (cont (lambda args 'null))
                                    (cont
                                        (sexy-apply exporter args (prep-options opts) top-cont top-err))))
                            top-err))
                    err))
            err)))

(define (cps-list xs)
    (if (pair? xs)
        (let ((head (cps (car xs))) (tail (sexy-compile-list (cdr xs))))
            (frag
                (head
                    env
                    (lambda (h)
                        (tail
                            env
                            (lambda (t) (cont (cons h t)))
                            err))
                    err)))
        (frag (cont '()))))

(define (cps-application code)
    (define fn-c (cps (car code)))
    (define args-opts (prepare-sexy-args (cdr code)))
    (define args-c (cps-list (car args-opts)))
    (define opts-c (cps-list (cdr args-opts)))
    (frag
        (fn-c
            env
            (lambda (f) 
                (args-c
                    env
                    (lambda (args)
                        (opts-c
                            env
                            (lambda (opts)
                                (sexy-apply f args (prep-options opts) cont err))
                            err))
                    err))
            err)))

)


(rem:

; http://matt.might.net/articles/cps-conversion/
; someday I'll grok this enough to implement it

(proc M (form)
    (when (not (atomic? form))
        (error (object 'type 'error 'form form 'name 'not-an-atom! 'to-text "WRONG!")))
    (if (not (pair? form))
        form
        (case form.head
            (quote) form
            (λ) (seq
                (def k (gencont)) ; user continuation
                (def e (genhand)) ; error continuation
                %($form.head $form.2 $(append form.3 (list k e)) @form.tail.tail.tail.tail)) ; remember the added IDs from pass 2
            (proc) (seq
                (def k 'return)    ; user continuation
                (def e (genhand))  ; error continuation
                %($form.head $form.2 $(append form.3 (list k e)) @form.tail.tail.tail.tail)) ; remember the added IDs from pass 2
            default: (error 'wtf))))

(proc T-c (form c)
    (debug (list 'T-c form c))
    (if (atomic? form)
        %($c $(M form))
        (case form.head
            (def) form
            (if) (seq
                (def k (gencont))
                %((λ ($k)
                    $(T-k form.1
                        (proc (p)
                            %(if $p
                                 $(T-c form.2 k)
                                 $(T-c form.3 k))))) $c))
            (seq) (T-k form.1
                    (proc (x)
                        (T-c form.2 c)))
            (wall) form
            (gate) form
            (capture) form
            (guard) form
            (error) form
            (load) form
            default: ; procedure application
                (T-k form.head
                    (proc (f)
                        (T*-k form.tail
                            (proc (args)
                                %($f @args $c))))))))

(proc T-k (form k)
    (debug (list 'T-k form k))
    (if (atomic? form)
        (k (M form))
        (case form.head
            (def) (seq
                (def rv (gensym "value"))
                %((λ ($rv)
                    (def form.1 $rv))))
            (if) (seq
                (def rv (gensym "value"))
                (def cont %(λ ($rv) $(k rv)))
                (T-k form.1
                    (proc (aexp)
                        %(if $aexp 
                            $(T-c form.2 cont)
                            $(T-c form.3 cont)))))
            (seq) (T-k form.1
                    (proc (x)
                        (T-k form.2 k)))
            (wall) form
            (gate) form
            (capture) form
            (guard) form
            (error) form
            (load) form
            default: ; procedure application
                (def rv (gensym "value"))
                (def cont %(λ ($rv) $(k rv)))
                (T-c form cont))))

(proc T*-k (exprs k)
    (if exprs.empty?
        (k ())
        (T-k exprs.head
            (proc (hd)
                (T*-k exprs.tail
                    (proc (tl)
                        (k (pair hd tl))))))))
)


