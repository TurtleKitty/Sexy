
(use gen-pass "generic.sxy")

(lib () pass)

(proc pass (form) ; FIXME add proc db to pass?
    (cps form))

(proc atomic? (form)
    (if (pair? form)
        ((send '(quote proc λ) 'has?) form.head)
        true))

(proc gencont ()
    (gensym "continuation"))

(proc genhand ()
    (gensym "handler"))

(proc genval ()
    (gensym "value"))

(proc error-object (name form to-text)
    (error (object 'name name 'form form 'to-text to-text)))

(proc cps-frag (cont hand body)
    %(λ (env $cont $hand) $body))

(proc cps (form)
    (if (and (pair? form) (list? form))
        (case form.head
            (quote)    (cps-quote form)
            (if)       (cps-if form)
            (seq)      (cps-seq form)
            (λ)        (cps-lambda form)
            (proc)     (cps-proc form)
            (wall)     (cps-wall form)
            (gate)     (cps-gate form)
            (capture)  (cps-capture form)
            (guard)    (cps-guard form)
            (error)    (cps-error form)
            (load)     (cps-load form)
            default:   (cps-application form))
        (cps-atom form)))

(proc cps-quote (form)
    (def cont (gencont))
    (def hand (genhand))
    (cps-frag
        cont
        hand
        %($cont $form.1)))

(proc cps-if (form)
    (def pred (cps form.1))
    (def if-true (cps form.2))
    (def if-false (cps form.3))
    (def cont (gencont))
    (def hand (genhand))
    (def pred-val (genval))
    (def bool (genval))
    (cps-frag
        cont
        hand
        %($pred
            env
            (λ ($pred-val)
                (send
                    (λ ($bool)
                        (if $bool
                            ($if-true  env $cont $hand)
                            ($if-false env $cont $hand)))
                    $hand
                    null
                    $pred-val
                    'to-bool))
            $hand)))

(proc cps-seq (form)
    ; all seqs should be binary by now
    (def cps-head (cps xs.head))
    (def cps-tail (cps xs.tail))
    (def cont (gencont))
    (def hand (genhand))
    (cps-frag
        cont
        hand
        %($cps-head
            env
            (λ () ($cps-tail env $cont $hand))
            $hand)))

(proc cps-lambda (form)
    ; strip ids as well
    (def cont (gencont))
    (def hand (genhand))
    (def lambda-cont (gencont))
    (def lambda-hand (genhand))
    (def new-args (pair lambda-cont (pair lambda-hand form.2)))
    (cps-frag
        cont
        hand
        %($cont (λ $new-args @form.tail.tail.tail))))

(proc cps-proc (form)
    ; strip ids as well - FIXME - only if we're converting to (sexy-primitive-proc env code exec)
    (def cont (gencont))
    (def hand (genhand))
    (def lambda-hand (genhand))
    (def new-args (pair 'return (pair lambda-hand form.2)))
    (cps-frag
        cont
        hand
        %($cont (λ $new-args @form.tail.tail.tail))))

(proc cps-wall (form)
    (def cont (gencont))
    (def hand (genhand))
    (def noob (genval))
    (def looker (genval))
    (def vals (genval))
    (def args form.1)
    (def cps-body (cps form.tail.tail))
    (cps-frag
        cont
        hand
        %(send
            (λ ($looker)
                ($looker
                    (λ ($vals)
                        (environment
                            (λ ($noob) ($cps-body $noob $cont $hand))
                            $hand
                            null
                            @(flatten (zip (quote $args) $vals))))
                    $hand
                    null
                    $args))
            $hand
            env
            'lookup-list)))

(proc (cps-gate form)
    (def cps-body (cps form.tail))
    (def cont (gencont))
    (def hand (genhand))
    (cps-frag
        cont
        hand
        %($cont
            (cps-body env identity $hand))))

; FIXME need a pass to convert globals to lookups after this one

(proc cps-capture (form)
    (def name form.1)
    (def lamb %(λ ($name) @form.tail.tail))
    (def cps-lamb (cps lamb))
    (def cont (gencont))
    (def hand (genhand))
    (def funk (genval))
    (def k-val (genval))
    (cps-frag
        cont
        hand
        %($cps-lamb
            env
            (λ ($funk)
                ($funk
                    identity
                    $hand
                    null
                    (λ ($k-val) ($cont $k-val))))
            $hand)))

(proc cps-guard (form)
    (def handler (cps form.1))
    (def cps-body (cps form.tail.tail))
    (def cont (gencont))
    (def hand (genhand))
    (def funk (genval))
    (def e (genval))
    (def k (genval))
    (cps-frag
        cont
        hand
        %($handler
            env
            (λ ($funk)
                (cps-body
                    env
                    $cont
                    (λ ($e $k) ($funk $cont $hand null $e $k))))
            $hand)))

(proc cps-error (form)
    (def error-obj (cps form.1))
    (def cont (gencont))
    (def hand (genhand))
    (def e (genval))
    (cps-frag
        $cont
        $hand
        ($error-obj
            env
            (λ ($e)
                ($hand $e $cont))
            $hand)))

(proc cps-list (xs)
    (def cont (gencont))
    (def hand (genhand))
    (def h (genval))
    (def t (genval))
    (if (pair? xs)
        (let (head (cps xs.head) tail (cps-list xs.tail))
            (cps-frag
                cont
                hand
                %($head
                    env
                    (λ ($h)
                        (tail
                            env
                            (λ ($t) ($cont (pair h t)))
                            $hand))
                    $hand)))
        (cps-frag cont hand %($cont ()))))

(proc cps-application (form)
    (def cps-proc (cps form.head))
    (def cps-args (cps-list form.tail))
    (def cont (gencont))
    (def hand (genhand))
    (def f (genval))
    (def yargs (genval))
    (cps-frag
        cont
        hand
        %($cps-proc
            env
            (λ ($f) 
                (cps-args
                    env
                    (λ ($yargs)
                        (sexy-primitive-apply $cont $hand $f $yargs))
                    $hand))
            $hand)))

(proc cps-atom (form)
    (def cont (gencont))
    (def hand (genhand))
    (def pass (cps-frag cont hand %($cont $form)))
    (if (symbol? form)
        (if (option? form)
            (error-object 'misplaced-option form "All options should be erased by now!")
            (case form
                (true false null env) pass
                default:
                    (if (global? form)
                        (cps-frag
                            cont
                            hand
                            (let (v (genval))
                                %($cont (send (λ ($v) ($cont $v)) hand null global 'lookup)))) ; FIXME this may be unnecessary
                        (cps-frag
                            cont
                            hand
                            (let (v (genval))
                                %($cont (send (λ ($v) ($cont $v)) hand null env 'lookup))))))) ; FIXME this was done in previous pass
        pass))


(rem:

(define (cps-load form)
    (define path (cadr form))
    (define module (if (hte? sexy-modules path) (htr sexy-modules path) (lambda args 'null)))
    (define load-env (local-env))
    (define args-opts (prepare-sexy-args (cddr form)))
    (define args-c (cps-list (car args-opts)))
    (define opts-c (cps-list (cdr args-opts)))
    (frag 
        (args-c
            env
            (lambda (args)
                (opts-c
                    env
                    (lambda (opts)
                        (module load-env top-cont top-err)
                        (lookup load-env 'sexy-library-export-procedure
                            (lambda (exporter)
                                (if (eq? exporter not-found)
                                    (cont (lambda args 'null))
                                    (cont
                                        (sexy-apply exporter args (prep-options opts) top-cont top-err))))
                            top-err))
                    err))
            err)))


; http://matt.might.net/articles/cps-conversion/
; someday I'll grok this enough to implement it

(proc M (form)
    (when (not (atomic? form))
        (error (object 'type 'error 'form form 'name 'not-an-atom! 'to-text "WRONG!")))
    (if (not (pair? form))
        form
        (case form.head
            (quote) form
            (λ) (seq
                (def k (gencont)) ; user continuation
                (def e (genhand)) ; error continuation
                %($form.head $form.2 $(append form.3 (list k e)) @form.tail.tail.tail.tail)) ; remember the added IDs from pass 2
            (proc) (seq
                (def k 'return)    ; user continuation
                (def e (genhand))  ; error continuation
                %($form.head $form.2 $(append form.3 (list k e)) @form.tail.tail.tail.tail)) ; remember the added IDs from pass 2
            default: (error 'wtf))))

(proc T-c (form c)
    (debug (list 'T-c form c))
    (if (atomic? form)
        %($c $(M form))
        (case form.head
            (def) form
            (if) (seq
                (def k (gencont))
                %((λ ($k)
                    $(T-k form.1
                        (proc (p)
                            %(if $p
                                 $(T-c form.2 k)
                                 $(T-c form.3 k))))) $c))
            (seq) (T-k form.1
                    (proc (x)
                        (T-c form.2 c)))
            (wall) form
            (gate) form
            (capture) form
            (guard) form
            (error) form
            (load) form
            default: ; procedure application
                (T-k form.head
                    (proc (f)
                        (T*-k form.tail
                            (proc (args)
                                %($f @args $c))))))))

(proc T-k (form k)
    (debug (list 'T-k form k))
    (if (atomic? form)
        (k (M form))
        (case form.head
            (def) (seq
                (def rv (gensym "value"))
                %((λ ($rv)
                    (def form.1 $rv))))
            (if) (seq
                (def rv (gensym "value"))
                (def cont %(λ ($rv) $(k rv)))
                (T-k form.1
                    (proc (aexp)
                        %(if $aexp 
                            $(T-c form.2 cont)
                            $(T-c form.3 cont)))))
            (seq) (T-k form.1
                    (proc (x)
                        (T-k form.2 k)))
            (wall) form
            (gate) form
            (capture) form
            (guard) form
            (error) form
            (load) form
            default: ; procedure application
                (def rv (gensym "value"))
                (def cont %(λ ($rv) $(k rv)))
                (T-c form cont))))

(proc T*-k (exprs k)
    (if exprs.empty?
        (k ())
        (T-k exprs.head
            (proc (hd)
                (T*-k exprs.tail
                    (proc (tl)
                        (k (pair hd tl))))))))
)


