#!/usr/local/bin/sexy run

(use check-sexy-syntax "syntax_checker.sxy" sys.log)
(use compile "compile.sxy")
(use cache-file "cache.sxy")

(everywhere
    (fun slurp-file (f)
        (sys.fs.from
            f
            (fn (p)
                p.read-text)))

    (fun read-file (fname)
        (parse (slurp-file fname)))

    (def macro-env (env.extend () ()))

    (fun expand (sexpr)
        (macro-env.expand sexpr))

    (fun read-expand (fname)
        (def struct (read-file fname))
        (expand struct))

    (fun compile-file (fname)
        (def expanded (read-expand fname))
        (def ok (check-sexy-syntax expanded))
        (if ok
            (let (compiled (compile (pair 'seq expanded)))
                (sys.say `(expanded ,expanded))
                (sys.say `(compiled ,compiled))
                (def cached-fname null) ;(cache-file fname compiled)
                (rem: compile golang from here?)
                cached-fname)
            (error 'syntax-error))))

(macro import-global-prelude ()
    (def expanded (read-expand "compiler/prelude.sxy"))
    `(def global-prelude ,expanded))

(macro import-default-load-symbols ()
    (def contents (read-file "compiler/default-load-symbols.sxy"))
    `(def default-load-symbols ,contents))

(import-global-prelude)
(import-default-load-symbols)

(def home-dir "~/.sexy")
(def sexy-module-dir   (cat home-dir "/modules"))
(def sexy-cache-dir    (cat home-dir "/compiled"))
(def sexy-symbols-file (cat home-dir "/symbols.sxy"))
(def sexy-load-symbol-env null)
(def cli-env env)

(fun start ()
    (def args rest)
    (when (= args.size 0)
        (usage))
    (fun prep-dir (path)
        (when (not (sys.fs.exists? path))
            (sys.fs.mkdir path)))
    (def cmd args.head.to-symbol)
    (prep-dir sexy-module-dir)
    (prep-dir sexy-cache-dir)
    (default-symbols-file)
    (load-symbols-env)
    (def control (:
        repl    sexy-repl
        eval    sexy-eval-string
        run     sexy-run
        check   sexy-check
        expand  sexy-expand
        compile sexy-compile
        clean   sexy-clean))
    (def handler (control cmd))
    (if handler
        (handler.apply args.tail opt)
        (seq
            (sys.log (cat "Unknown command: " cmd))
            (usage))))

(fun usage ()
    (sys.say (text:
Usage:

sexy repl
sexy eval "<code string>"
sexy run <filename>
sexy check <filename>
sexy expand <filename>
sexy compile <filename>
sexy clean))
    (sys.proc.exit))

(fun default-symbols-file ()
    (when (not (sys.fs.exists? sexy-symbols-file))
        (sys.fs.to
            sexy-symbols-file
            (fn (f)
                (f.print default-load-symbols)))))

(fun load-symbols-env ()
    (def symbol-env (make-env))
    (def expanded
        (read-expand sexy-symbols-file))
    (def ok (check-sexy-syntax expanded))
    (when ok.not
        (error 'syntax-error-in-symbols-file))
    (symbol-env.eval expanded)
    (set! sexy-load-symbol-env symbol-env))

(fun sexy-repl ()
    (repl (cli-env.extend () ()) sys.stdin sys.stdout sys.stderr))

(fun sexy-eval-string (str)
    (def expanded (expand (parse str)))
    (sys.say
        (cli-env.eval (pair 'seq expanded))))

(fun sexy-run (filename)
    ; compile then exec
    (def cfile (compile-file filename))
    (sys.shell (cat with: " " cfile (rest.join " "))))

(fun sexy-check (filename)
    (def macro-env (cli-env.extend () ()))
    (def its-good (check-sexy-syntax (read-expand filename)))
    (sys.say (cat "Sexy syntax check complete: " (if its-good 'ok 'FAIL))))

(fun sexy-expand (filename)
    ; expand and print - don't compile or cache
    (sys.write (read-expand filename)))

(fun sexy-compile (filename)
    ; expand, compile, and cache - don't run
    (def cfile (compile-file filename))
    (sys.say (cat "File " filename " compiled to " cfile ".")))

(fun sexy-clean ()
    (def mods (sys.fs.ls sexy-module-dir))
    (def cached (sys.fs.ls sexy-cache-dir))
    (def files (append mods cached))
    (let (f files.head fs files.tail)
        (sys.fs.rm f)
        (if fs
            (loop fs.head fs.tail)
            'ok)))

(start.apply sys.rest sys.opt)

