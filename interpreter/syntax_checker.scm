
(define (check-sexy-syntax prog)
    (define (checky form rest)
        (define (go-on ok)
            (if (not ok)
                #f
                (if (eq? rest '())
                    ok
                    (checky (car rest) (cdr rest)))))
        (if (list? form)
            (if (eq? form '())
                (go-on #t)
                (go-on
                    (let ((head (car form)))
                        (case head
                            ((def)      (check-sexy-def form))
                            ((quote)    (check-sexy-quote form))
                            ((if)       (check-sexy-if form))
                            ((seq)      (check-sexy-seq form))
                            ((set!)     (check-sexy-set! form))
                            ((operator) (check-sexy-operator form))
                            ((fn)       (check-sexy-fn form))
                            ((wall)     (check-sexy-wall form))
                            ((gate)     (check-sexy-gate form))
                            ((capture)  (check-sexy-capture form))
                            ((guard)    (check-sexy-guard form))
                            ((error)    (check-sexy-error form))
                            ((ensure)   (check-sexy-ensure form))
                            ((load)     (check-sexy-load form))
                            ((syntax)   (check-sexy-syntax-export form))
                            (else       #t)))))
            (go-on #t)))
    (if (and (pair? prog) (list? prog))
        (let ((first (car prog)))
            (if (and (pair? first) (eq? 'modules (car first)))
                (checky (cadr prog) (cddr prog)) ; skip (modules)
                (checky first (cdr prog))))
        #t))

(define (say x)
    (display x)
    (newline))

(define (syntax-error code e usage)
    (say "Syntax error:")
    (say code)
    (say e)
    (say usage)
    (newline)
    #f)

(define (check-sexy-def code)
    (define usage '(def <name> <value>))
    (if (not (symbol? (cadr code)))
        (syntax-error code "def requires a symbol as its first argument." usage)
        (if (< (length code) 3)
            (syntax-error code "def: too few arguments" usage)
            (if (> (length code) 3)
                (syntax-error code "def: too many arguments" usage)
                #t))))

(define (check-sexy-quote code)
    (define usage '(quote <s-expression>))
    (if (not (eq? (length code) 2))
        (syntax-error code "quote takes one argument." usage)
        #t))

(define (check-sexy-if code)
    (define usage '(if <predicate> <consequent> <alternative>))
    (if (< (length code) 4)
        (syntax-error code "if: too few arguments" usage)
        (if (> (length code) 4)
            (syntax-error code "if: too many arguments" usage)
            #t)))

(define (check-sexy-seq code)
    (define usage '(seq <form> ...))
    (if (< (length code) 2)
        (syntax-error code "seq: empty sequences are forbidden." usage)
        #t))

(define (check-sexy-set! code)
    (define usage '(set! <name> <value>))
    (if (not (symbol? (cadr code)))
        (syntax-error code "set! requires a symbol as its first argument." usage)
        (if (< (length code) 3)
            (syntax-error code "set!: too few arguments" usage)
            (if (> (length code) 3)
                (syntax-error code "set!: too many arguments" usage)
                #t))))

(define (check-sexy-operator code)
    (define usage '(operator (<arg> ...) <body> ...))
    (if (not (list? (cadr code)))
        (syntax-error code "operator: second argument must be a list of formals." usage)
        (if (< (length code) 3)
            (syntax-error code "operator: at least one body form is required." usage)
            #t)))

(define (check-sexy-fn code)
    (define usage '(fn (<arg> ...) <body> ...))
    (if (not (list? (cadr code)))
        (syntax-error code "fn: second argument must be a list of formals." usage)
        (if (< (length code) 3)
            (syntax-error code "fn: at least one body form is required." usage)
            #t)))

(define (check-sexy-wall code)
    (define usage '(wall (<arg> ...) <body> ...))
    (if (< (length code) 3)
        (syntax-error code "wall: at least one body form is required." usage)
        (if (not (pair? (cadr code)))
            (syntax-error code "wall: second argument must be a list of parameters to pass." usage)
            #t)))

(define (check-sexy-gate code)
    (define usage '(gate <body> ...))
    (if (< (length code) 2)
        (syntax-error code "gate: too few arguments." usage)
        #t))

(define (check-sexy-capture code)
    (define usage '(capture <name> <body> ...))
    (if (< (length code) 3)
        (syntax-error code "capture: too few arguments." usage)
        (if (not (symbol? (cadr code)))
            (syntax-error code "capture requires a symbol as its first argument." usage)
            #t)))

(define (check-sexy-guard code)
    (define usage '(guard (fn (error restart) <body> ...) <body> ...))
    (if (< (length code) 3)
        (syntax-error code "guard: too few arguments." usage)
        #t))
        
(define (check-sexy-error code)
    (define usage '(error <object>))
    (if (< (length code) 2)
        (syntax-error code "error: too few arguments." usage)
        (if (> (length code) 2)
            (syntax-error code "error: too many arguments." usage)
            #t)))

(define (check-sexy-ensure code)
    (define usage '(ensure <thunk> <body> ...))
    (if (< (length code) 3)
        (syntax-error code "ensure: too few arguments." usage)
        #t))

(define (check-sexy-load code)
    (define usage '(load <symbol-or-string-path> <arg> ...))
    (if (< (length code) 2)
        (syntax-error code "load: too few arguments." usage)
        (let ((uri (cadr code)))
            (if (not (or (symbol? uri) (string? uri)))
                (syntax-error code "load: first argument must be a symbol or string." usage)
                #t))))

(define (check-sexy-syntax-export code)
    (define usage '(syntax <name> <operator> ...))
    (if (eq? (modulo (length code) 2) 0)
        (syntax-error code "syntax: must have an even number of arguments." usage)
        (begin 
            (for-pairs
                (lambda (k v)
                    (if (not (symbol? k))
                        (syntax-error code "syntax: exported names must be symbols.")
                        #t))
                (cdr code))
            #t)))

