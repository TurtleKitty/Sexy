
(define (check-sexy-syntax prog)
    (define (checky form rest)
        (define (go-on ok)
            (if (not ok)
                #f
                (if (eq? rest '())
                    ok
                    (checky (car rest) (cdr rest)))))
        (if (list? form)
            (if (eq? form '())
                (go-on #t)
                (go-on
                    (let ((head (car form)))
                        (case head
                            ((def)      (check-sexy-def form))
                            ((quote)    (check-sexy-quote form))
                            ((if)       (check-sexy-if form))
                            ((seq)      (check-sexy-seq form))
                            ((set!)     (check-sexy-set! form))
                            ((位)        (check-sexy-lambda form))
                            ((proc)     (check-sexy-proc form))
                            ((wall)     (check-sexy-wall form))
                            ((gate)     (check-sexy-gate form))
                            ((capture)  (check-sexy-capture form))
                            ((guard)    (check-sexy-guard form))
                            ((error)    (check-sexy-error form))
                            ((ensure)   (check-sexy-ensure form))
                            ((load)     (check-sexy-load form))
                            ((syntax)   (check-sexy-syntax-export form))
                            (else       #t)))))
            (go-on #t)))
    (if (and (pair? prog) (list? prog))
        (let ((first (car prog)))
            (if (and (pair? first) (eq? 'modules (car first)))
                (checky (cadr prog) (cddr prog)) ; skip (modules)
                (checky first (cdr prog))))
        #t))

(define (say x)
    (display x)
    (newline))

(define (syntax-error code e usage)
    (say "Syntax error:")
    (say code)
    (say e)
    (say usage)
    (newline)
    #f)

(define (check-sexy-def code)
    (define usage '(def <name> <value>))
    (if (< (length code) 3)
        (syntax-error code "def: too few arguments." usage))
        (let ((name (cadr code)))
            (cond
                ((not (symbol? name))
                    (syntax-error code "def requires a symbol as its first argument." usage))
                ((< (length code) 3)
                    (syntax-error code "def: too few arguments" usage))
                ((> (length code) 3)
                    (syntax-error code "def: too many arguments" usage))
                ((holy? name)
                    (syntax-error code (string-join `("def:" ,(blasphemy name)) " ") usage))
                (else #t))))

(define (check-sexy-quote code)
    (define usage '(quote <s-expression>))
    (if (not (eq? (length code) 2))
        (syntax-error code "quote takes one argument." usage)
        #t))

(define (check-sexy-if code)
    (define usage '(if <predicate> <consequent> <alternative>))
    (if (< (length code) 4)
        (syntax-error code "if: too few arguments" usage)
        (if (> (length code) 4)
            (syntax-error code "if: too many arguments" usage)
            #t)))

(define (check-sexy-seq code)
    (define usage '(seq <form> ...))
    (if (< (length code) 2)
        (syntax-error code "seq: empty sequences are forbidden." usage)
        #t))

(define (check-sexy-macro code)
    (define usage '(macro <name> (<arg> ...) <body> ...))
    (if (< (length code) 4)
        (syntax-error code "macro requires at least three arguments." usage))
    (let ((name (cadr code)))
        (cond
            ((not (symbol? (cadr code)))
                (syntax-error code "macro requires a symbol as its first argument." usage))
            ((not (list? (caddr code)))
                (syntax-error code "macro: second argument must be a list of formals." usage))
            ((< (length code) 4)
                (syntax-error code "macro: at least one body form is required." usage))
            ((holy? name)
                (syntax-error code (string-join `("macro:" ,(blasphemy name)) " ") usage))
            (else #t))))

(define (check-sexy-lambda code)
    (define usage '(位 (<arg> ...) <body>))
    (if (not (list? (cadr code)))
        (syntax-error code "位: second argument must be a list of formals." usage)
        (if (not (= (length code) 3))
            (syntax-error code "位: one body form is required; only one is allowed." usage)
            #t)))

(define (check-sexy-proc code)
    (define usage '(proc <name?> (<arg> ...) <body> ...))
    (define arg1 (cadr code))
    (if (symbol? arg1)
        (let ((name arg1) (args (caddr code)))
            (if (not (list? args))
                (syntax-error code "named proc: third argument must be a list of formals." usage)
                (if (< (length code) 4)
                    (syntax-error code "proc: at least one body form is required." usage)
                    #t)))
        (let ((args arg1)) 
            (if (not (list? args))
                (syntax-error code "anon proc: second argument must be a list of formals." usage)
                (if (< (length code) 3)
                    (syntax-error code "proc: at least one body form is required." usage)
                    #t)))))

(define (check-sexy-wall code)
    (define usage '(wall (<arg> ...) <body> ...))
    (if (< (length code) 3)
        (syntax-error code "wall: at least one body form is required." usage)
        (if (not (pair? (cadr code)))
            (syntax-error code "wall: second argument must be a list of parameters to pass." usage)
            #t)))

(define (check-sexy-gate code)
    (define usage '(gate <body> ...))
    (if (< (length code) 2)
        (syntax-error code "gate: too few arguments." usage)
        #t))

(define (check-sexy-capture code)
    (define usage '(capture <name> <body> ...))
    (if (< (length code) 3)
        (syntax-error code "capture: too few arguments." usage)
        (if (not (symbol? (cadr code)))
            (syntax-error code "capture requires a symbol as its first argument." usage)
            #t)))

(define (check-sexy-guard code)
    (define usage '(guard (proc (error restart) <body> ...) <body> ...))
    (if (< (length code) 3)
        (syntax-error code "guard: too few arguments." usage)
        #t))
        
(define (check-sexy-error code)
    (define usage '(error <object>))
    (if (< (length code) 2)
        (syntax-error code "error: too few arguments." usage)
        (if (> (length code) 2)
            (syntax-error code "error: too many arguments." usage)
            #t)))

(define (check-sexy-ensure code)
    (define usage '(ensure <thunk> <body> ...))
    (if (< (length code) 3)
        (syntax-error code "ensure: too few arguments." usage)
        #t))

(define (check-sexy-load code)
    (define usage '(load <symbol-or-string-path> <arg> ...))
    (if (< (length code) 2)
        (syntax-error code "load: too few arguments." usage)
        (let ((uri (cadr code)))
            (if (not (or (symbol? uri) (string? uri)))
                (syntax-error code "load: first argument must be a symbol or string." usage)
                #t))))

(define (check-sexy-syntax-export code)
    (define usage '(syntax <name> <operator> ...))
    (if (eq? (modulo (length code) 2) 0)
        (syntax-error code "syntax: must have an even number of arguments." usage)
        (begin 
            (for-pairs
                (lambda (k v)
                    (if (not (symbol? k))
                        (syntax-error code "syntax: exported names must be symbols.")
                        #t))
                (cdr code))
            #t)))

