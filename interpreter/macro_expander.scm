
(define done-been-expanded (mkht))

(define expand-err
    (lambda (ex continue)
        (debug 'compile-error
            (if (and (hash-table? ex) (eq? (sexy-send-atomic ex 'type) 'error))
                (map (lambda (f) (sexy-view (sexy-send-atomic ex f))) '(name to-text form)))
                (sexy-view ex))
        (exit)))

(define (sexy-expand code env)
    (define (expand x)
        (sexy-expand x env))
    (define (noob)
        (sexy-environment env))
    (define (look-it-up x)
        (if (sexy-global? x)
            (glookup x)
            (lookup env x top-cont expand-err)))
    (define (sexy-macro? obj)
        (and (hash-table? obj) (eq? (htr obj 'type) 'operator)))
    (if (not (list? code))
        code
        (if (eq? code '())
            '()
            (let ((head (car code)))
                (case head
                    ((load)
                        (if (check-sexy-load code)
                            (let ((p (make-module-absolute-path (cadr code))))
                                (if (hte? done-been-expanded p)
                                    (cons 'load (cons p (cddr code)))
                                    (begin
                                        (hts! done-been-expanded p #t)
                                        (sexy-expand-load code env))))
                            (exit)))
                    ((macro)
                        (let* ((noo-env (noob)) (nucode (map (lambda (c) (sexy-expand c noo-env)) code)))
                            ((sexy-compile nucode) env top-cont expand-err)
                            nucode))
                    ((macro-eval)
                        (let ((expanded (expand (cons 'seq (cdr code)))))
                            ((sexy-compile expanded) env top-cont expand-err)
                            ''macro-eval-was-here))
                    ((seq)
                        (if (check-sexy-seq code)
                            (let ((expanded (map expand code)))
                                (prep-defs (cdr expanded) env top-cont expand-err)
                                expanded)
                            (exit)))
                    ((quote)
                        (if (check-sexy-quote code)
                            code
                            (exit)))
                    ((syntax)
                        (if (check-sexy-syntax-export code)
                            (let ((syn-fn
                                    (lambda ()
                                        (apply sexy-record (cdr code))))
                                  (setter! (sexy-apply-wrapper (sexy-send-atomic env 'def!))))
                                (setter! 'syntax syn-fn)
                                'null)
                            (exit)))
                    ((Î» proc)
                        (cons head (sexy-expand (cdr code) (noob))))
                    (else 
                        (if (symbol? head)
                            (let ((obj (look-it-up head)))
                                (if (sexy-macro? obj)
                                    (let ((arg-pair (prepare-sexy-args (cdr code))))
                                        (define args (car arg-pair))
                                        (define opts (prep-options (cdr arg-pair)))
                                        (sexy-expand
                                            (sexy-apply obj args opts top-cont expand-err)
                                            env))
                                    (map expand code)))
                            (map expand code))))))))

(define (sexy-expand-load code env)
    (define arg-pair (prepare-sexy-args (cdr code)))
    (define args (car arg-pair))
    (define path (car args))
    (define abs-path (make-module-absolute-path path))
    (define prog-env (local-env))
    (define prog
        (if (or (symbol? path) (string? path))
            (read-expand-cache-prog path prog-env)
            (sexy-error code "load: path must be a symbol or a string.")))
    (define load-err
        (lambda (e cont)
            (debug 'LOAD-ERROR e)
            (exit)))
    (define (looker name)
        (lookup prog-env name top-cont load-err))
    (define exporter (looker 'syntax))
    (if (not (eq? exporter not-found))
        (let ()
            (define syn-rec (exporter))
            (define names (sexy-send-atomic syn-rec 'keys))
            (define (set-em! k)
                (define defr! (sexy-send-atomic env 'def!))
                (define op-val (looker ((sexy-send-atomic syn-rec 'get) k)))
                (defr! k op-val))
            (map set-em! names))
        #f)
    (cons 'load (cons abs-path (cddr code))))


