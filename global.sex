
; global environment

(def macro
    (operator (name vars body)
        (list 'def name
            (pair
                'operator
                (pair vars (pair body rest))))))

(macro fun (name vars body)
    (list 'def name
        (pair
            'fn
            (pair vars (pair body rest)))))

(macro lib (vars body)
    (list 'def 'sexy-library-export-function
        (pair
            'fn
            (pair vars (pair body rest)))))

(macro use (name uri)
    (list 'def name
        (pair 'load
            (pair uri (rest.append opt.to-plist)))))

(macro thunk ()
    (pair 'fn (pair '() rest)))

(fun isa? (thing type)
    (= thing.type type))

(fun bool? (thing)
    (isa? thing 'bool))

(fun fn? (thing)
    (isa? thing 'fn))

(fun symbol? (thing)
    (isa? thing 'symbol))

(fun string? (thing)
    (isa? thing 'string))

(fun null? (thing)
    (= thing null))

(fun record? (thing)
    (isa? thing 'record))

(fun not (x)
    x.to-bool.not)

(fun != (x y)
    (not (= x y)))

(fun >= (x y)
    (not (< x y)))

(fun <= (x y)
    (not (> x y)))

(macro and (x)
    (if rest
        (list 'if x (and.apply rest) 'false)
        (list 'send x ''to-bool)))

(fun and? (x)
    (if x
        (if rest
            (and?.apply rest)
            true)
        false))

(macro or (x)
    (if rest
        (list 'if x 'true (or.apply rest))
        (list 'if x x 'false)))

(fun or? (x)
    (if x
        true
        (if rest
            (or?.apply rest)
            false)))

(fun nand ()
    (not (and?.apply rest)))

(fun nor ()
    (not (or?.apply rest)))

(fun xor (x y)
    (nor (and? x y) (nor x y)))

(fun identity (x) x)

(fun curry (f arg)
    (fn ()
        (apply f (pair arg rest))))

(fun compose (f g)
    (fn () (f (apply g rest))))

(fun append (xs ys)
    (def rv (xs.append ys))
    (if rest
        (append.apply (pair rv rest))
        rv))

(fun apply (f args)
    (f.apply args))

(macro let (name/vars)
    (def is-named (symbol? name/vars))
    (def vars (if is-named rest.head name/vars))
    (fun sep (x y xs names vals)
        (if xs.empty?
            (pair ((pair x names) 'reverse) ((pair y vals) 'reverse))
            (sep xs.head xs.1 xs.tail.tail (pair x names) (pair y vals))))
    (def p
        (if vars.empty?
            (pair '() '())
            (sep vars.head vars.1 vars.tail.tail '() '())))
    (def fn-form (append (list 'fn p.head) (if is-named rest.tail rest)))
    (if is-named
        (seq
            (def args (gensym))
            (list 'let (list args (pair 'list p.tail))
                    (list 'def name/vars fn-form)
                    (list 'apply name/vars args)))
        (pair fn-form p.tail)))

(macro % (head tail) ; pair literal
    (list 'pair (list 'quote head) tail))

(macro : () ; record literal
    (pair 'record
        (if (pair? rest)
            (if (!= (mod rest.size 2) 0)
                (error (list ': "requires an even number of arguments"))
                (let loop (k rest.head v rest.1 xs rest.tail.tail acc '())
                    (def noob (pair (list 'quote k) (pair v acc)))
                    (if (pair? xs)
                        (loop xs.head xs.tail.head xs.tail.tail noob)
                        noob)))
            '())))

(macro cond ()
    (def default
        (if opt.default
            opt.default
            (list 'error (list 'list ''cond-no-matching-clause (list 'pair ''cond (list 'quote rest))))))
    (if (< rest.size 2)
        (error (list 'bad-cond "cond should have at least one predicate and consequent." (pair 'cond rest)))
        (let loop (pred rest.0 conseq rest.1 remaining rest.tail.tail)
            (if remaining
                (list 'if pred conseq (loop remaining.0 remaining.1 remaining.tail.tail))
                (list 'if pred conseq default)))))

(macro qq (expr)
    (fun constant? (expr)
        (if (pair? expr)
            (= expr.head 'quote)
            (not (symbol? expr))))
    (fun combine-skeletons (left right expr)
        (cond
            (and (constant? left) (constant? right))
                (if (and (= (env.eval left)  expr.head)
                         (= (env.eval right) expr.tail))
                    (list 'quote expr)
                    (list 'quote (pair (env.eval left) (env.eval right))))
            (= right '())
                (list 'list left)
            (and (pair? right) (= right.head 'list))
                (pair 'list (pair left right.tail))
            default: (list 'pair left right)))
    (fun expand-quasiquote (expr nesting)
        (cond
            (not (pair? expr))
                (if (constant? expr)
                    expr
                    (list 'quote expr))
            (and (is? expr.head 'unq) (= expr.size 2))
                (if nesting.zero?
                    expr.1
                    (combine-skeletons
                        ''unq
                        (expand-quasiquote expr.tail nesting.dec)
                        expr))
            (and (is? expr.head 'qq) (= expr.size 2))
                (combine-skeletons
                    ''qq
                    (expand-quasiquote expr.tail nesting.inc)
                    expr)
            (and (pair? expr.head) (= expr.head.head 'unqs) (= expr.head.size 2))
                (if (= nesting 0)
                    (list 'append
                          expr.head.1
                          (expand-quasiquote expr.tail nesting))
                    (combine-skeletons
                        (expand-quasiquote expr.head nesting.dec)
                        (expand-quasiquote expr.tail nesting)
                        expr))
            default:
                (combine-skeletons
                    (expand-quasiquote expr.head nesting)
                    (expand-quasiquote expr.tail nesting)
                    expr)))
    (expand-quasiquote expr 0))

(macro when (pred)
    (qq
        (if (unq pred)
            (seq (unqs rest))
            null)))

(macro case (val)
    (def default
        (if opt.default
            opt.default
            (list 'error (list 'list ''case-no-matching-clause (list 'pair ''case (list 'quote rest))))))
    (if (< rest.size 2)
        (error (list 'bad-case "case should have at least one predicate and consequent." (pair 'case rest)))
        (seq
            (def cval (gensym))
            (qq
                (let ((unq cval) (unq val))
                    (unq
                        (let loop (set rest.0 conseq rest.1 remaining rest.tail.tail)
                            (def pred (qq ((send (quote (unq set)) 'has?) (unq cval))))
                            (if remaining
                                (list 'if pred conseq (loop remaining.0 remaining.1 remaining.tail.tail))
                                (list 'if pred conseq default)))))))))

(macro while (pred body)
    ; call (next <value>) to skip the rest of the bodies and go to the next loop (continue)
    ;     if predicate evals false, <value> will be returned from the while expression
    ; call (return <value>) to terminate the loop and return said value (break)
    (def loop (gensym))
    (def rv (gensym))
    (qq
        ((thunk
            (def (unq loop)
                (fn ((unq rv))
                    (macro next (v) (list 'return (list '(unq loop) v)))
                    (macro last (v) (qq (return (unq v))))
                    (if (unq pred)
                        ((unq loop) (seq (unqs (pair body rest))))
                        (unq rv))))
            ((unq loop) null)))))

(macro _ (body)
    (def uscore (gensym))
    (def bodies (pair body rest))
    (fun rename (form)
        (if (pair? form)
            (if (= form.head '_)
                form
                (form.map rename))
            (if (= form '_)
                uscore
                form)))
    (qq
        (fn ((unq uscore))
            (unqs (rename bodies)))))

(macro with-gensyms (gs)
    (qq
        (let (unq (apply append (gs.map (_ (list _ '(gensym))))))
            (unqs rest))))

(macro for (init pred update body)
    (def bodies (pair body rest))
    (with-gensyms (loop rv tmp)
        (qq
            (let (unq init)
                (def (unq loop)
                    (fn ((unq rv))
                        (macro redo (v) (list 'return (list '(unq loop) v)))
                        (macro next (v) (list 'seq '(unq update) (list 'return (list '(unq loop) v))))
                        (macro last (v) (qq (return (unq v))))
                        (if (unq pred)
                            (let ((unq tmp) (seq (unqs bodies)))
                                (unq update)
                                ((unq loop) (unq tmp)))
                            (unq rv))))
                ((unq loop) null)))))

(macro each (name arg body)
    (def bodies (pair body rest))
    (with-gensyms (xs loop)
        (qq
            (let ((unq xs) (send (unq arg) 'to-list))
                (fun (unq loop) ((unq name))
                    (unqs bodies))
                ((send (unq xs) 'each) (unq loop))))))

(fun range (start end)
    (def step (if opt.step opt.step 1))
    (let loop (i start acc '())
        (if (> i end)
            acc.reverse
            (loop (+ i step) (pair i acc)))))

(macro matrix ()
    ; (matrix ((0 0 1) (0 0 2)) ((0 1 1) (0 2 1))) -> (^ (^ (^ 0 0 1) (^ 0 0 2)) (^ (^ 0 1 1) (^ 0 2 1)))
    (qq
        (vector
            (unqs
                (rest.map
                    (_ (if (pair? _)
                          (qq (matrix (unqs _)))
                          _)))))))

(macro gen (name body)
    (qq
        (def (unq name)
            (let (default (fn () (unqs (pair body rest)))
                  clauses (vector.apply ((send (range 0 7) 'map) (_ '())))) ; max arity of 7 for generic functions
                (fun add-clause! (pred body)
                    (def idx pred.arity)
                    (clauses.set!
                        idx
                        (pair (pair pred body) (clauses idx))))
                (fun set-default! (body)
                    (set! default body))
                (fun gen-apply ()
                    (def arity rest.size)
                    (def the-rest rest)
                    (let loop (n arity)
                        (def cs (clauses n))
                        (fun n-zero ()
                            (if n.zero?
                                (default.apply the-rest)
                                (loop n.dec)))
                        (if (not (pair? cs))
                            (n-zero)
                            (let larp (x cs.head xs cs.tail)
                                (if (x.head.apply the-rest)
                                    (x.tail.apply the-rest)
                                    (if (pair? xs)
                                        (larp xs.head xs.tail)
                                        (n-zero)))))))
                (fun view ()
                    (send
                        (pair clauses (pair 'default default))
                        'view))
                (object
                    'add-clause! add-clause!
                    'set-default! set-default!
                    'apply gen-apply
                    'view view
                    (unq 'auto:) '(view)))))) ; not sure why (unq (quote keyword:)) works, but I'll take it

(macro spec (name args pred body)
    (qq ((send (unq name) 'add-clause!)
            (fn (unq args) (unq pred))
            (fn (unq args) (unqs (pair body rest))))))

(fun ndx (n x)
    (fun dx ()
        (+ 1 (rand x)))
    (let loop (m n total 0)
        (if m.zero?
            total
            (loop m.dec (+ total (dx))))))

(fun repl (e in out err)
    (out.print "(sexy) ")
    (def input (in.read))
    (def result (e.eval input))
    (out.say result)
    (repl e in out err))

; reserving for future use

(def ! null)
(def ? null)
(def $ null)
(def @ null)
(def & null)
(def ~ null)
(def ^ null)

