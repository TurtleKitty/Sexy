
; global environment

(def macro
    (operator (name vars body)
        (list 'def name
            (pair
                'operator
                (pair vars (pair body rest))))))

(macro fun (name vars body)
    (list 'def name
        (pair
            'fn
            (pair vars (pair body rest)))))

(macro lib (vars body)
    (list 'def 'sexy-library-export-function
        (pair
            'fn
            (pair vars (pair body rest)))))

(macro use (name uri)
    (list 'def name
        (pair 'load
            (pair uri (rest.append opt.to-plist)))))

(macro thunk ()
    (pair 'fn (pair '() rest)))

(fun isa? (thing type)
    (= thing.type type))

(fun bool? (thing)
    (isa? thing 'bool))

(fun fn? (thing)
    (isa? thing 'fn))

(fun null? (thing)
    (= thing null))

(fun and (x)
    (if x
        (if rest
            (and.apply rest)
            true)
        false))

(fun or (x)
    (if x
        true
        (if rest
            (or.apply rest)
            false)))

(fun not (x)
    x.to-bool.not)

(fun != (x y)
    (not (= x y)))

(fun nand ()
    (not (and.apply rest)))

(fun nor ()
    (not (or.apply rest)))

(fun xor (x y)
    (nor (and x y) (nor x y)))

(macro let (name vars)
    (fun sep (x y xs names vals)
        (if xs.empty?
            (pair ((pair x names) 'reverse) ((pair y vals) 'reverse))
            (sep xs.head xs.1 xs.tail.tail (pair x names) (pair y vals))))
    (def p
        (if vars.empty?
            (pair '() '())
            (sep vars.head vars.1 vars.tail.tail '() '())))
    (def dname (list 'def name (((list 'fn p.head) 'append) rest)))
    (list 'seq dname (pair name p.tail)))

(macro % (head tail)
    (list 'pair (list 'quote head) tail))

(macro : () ; record literal
    (pair 'record
        (if (pair? rest)
            (if (!= (mod rest.size 2) 0)
                (error (list ': "requires an even number of arguments"))
                (let loop (k rest.head v rest.1 xs rest.tail.tail acc '())
                    (def noob (pair (list 'quote k) (pair v acc)))
                    (if (pair? xs)
                        (loop xs.head xs.tail.head xs.tail.tail noob)
                        noob)))
            '())))

(fun ndx (n x)
    (fun dx ()
        (+ 1 (rand x)))
    (let loop (m n total 0)
        (if m.zero?
            total
            (loop m.dec (+ total (dx))))))

; awaiting quasiquote...
;(macro spec (name pred exec)
;    (def obj (env.lookup name))
;    (def is-local (env.local? name))
;    (if (not (fn? obj))
;        (error "spec is used to specialize functions.")
;        (seq
;            (def fs obj.formals)
;            (def foo (gensym))
;            (def noob
;                `(fn ,fs
;                    (if ((fn ,fs ,pred) ,@fs)
;                        ((fn ,fs ,exec) ,@fs)
;                        (,foo (list ,@fs)))))
;            (if is-local
;                ; This will not work with globals.  Think on it some more.
;                `(seq (def ,foo ,name) (set! ,name ,noob))
;                `(seq (def ,foo ,name) (def ,name ,noob))))))


