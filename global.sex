
; global environment

(macro fun (name vars body)
    (list 'def name
        (pair
            'fn
            (pair vars (pair body rest)))))

(fun isa? (thing type)
    (= thing.type type))

(fun bool? (thing)
    (isa? thing 'bool))

(fun fn? (thing)
    (isa? thing 'fn))

(fun null? (thing)
    (= thing null))

(fun and (x)
    (if x
        (if rest
            (and.apply rest)
            true)
        false))

(fun fooooo () fooooo)

(fun square (x)
    (if (> x 1000)
        true
            (seq
                (show x)
                (square (* x x)))))

(macro let (name vars)
    (fun sep (x y xs names vals)
        (if xs.empty?
            (pair ((pair x names) 'reverse) ((pair y vals) 'reverse))
            (sep xs.head xs.1 xs.tail.tail (pair x names) (pair y vals))))
    (def p
        (if vars.empty?
            (pair '() '())
            (sep vars.head vars.1 vars.tail.tail '() '())))
    (def dname (list 'def name (((list 'fn p.head) 'append) rest)))
    (list (list 'fn '() dname (pair name p.tail))))

; awaiting quasiquote...
;(macro spec (name pred exec)
;    (def obj (env.lookup name))
;    (def is-local (env.local? name))
;    (if (not (fn? obj))
;        (error "spec is used to specialize functions.")
;        (seq
;            (def fs obj.formals)
;            (def foo (gensym))
;            (def noob
;                `(fn ,fs
;                    (if ((fn ,fs ,pred) ,@fs)
;                        ((fn ,fs ,exec) ,@fs)
;                        (,foo (list ,@fs)))))
;            (if is-local
;                `(seq (def ,foo ,name) (set! ,name ,noob))
;                `(seq (def ,foo ,name) (def ,name ,noob))))))


