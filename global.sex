
; global environment

(def macro
    (operator (name vars body)
        (list 'def name
            (pair
                'operator
                (pair vars (pair body rest))))))

(macro fun (name vars body)
    (list 'def name
        (pair
            'fn
            (pair vars (pair body rest)))))

(macro lib (vars body)
    (list 'def 'sexy-library-export-function
        (pair
            'fn
            (pair vars (pair body rest)))))

(macro use (name uri)
    (list 'def name
        (pair 'load
            (pair uri (rest.append opt.to-plist)))))

(macro thunk ()
    (pair 'fn (pair '() rest)))

(fun isa? (thing type)
    (= thing.type type))

(fun bool? (thing)
    (isa? thing 'bool))

(fun fn? (thing)
    (isa? thing 'fn))

(fun symbol? (thing)
    (isa? thing 'symbol))

(fun string? (thing)
    (isa? thing 'string))

(fun null? (thing)
    (= thing null))

(fun record? (thing)
    (isa? thing 'record))

(fun not (x)
    x.to-bool.not)

(fun != (x y)
    (not (= x y)))

(fun >= (x y)
    (not (< x y)))

(fun <= (x y)
    (not (> x y)))

(macro and (x)
    (if rest
        (list 'if x (and.apply rest) 'false)
        (list 'send x ''to-bool)))

(fun and? (x)
    (if x
        (if rest
            (and?.apply rest)
            true)
        false))

(macro or (x)
    (if rest
        (list 'if x 'true (or.apply rest))
        (list 'send x ''to-bool)))

(fun or? (x)
    (if x
        true
        (if rest
            (or?.apply rest)
            false)))

(fun nand ()
    (not (and?.apply rest)))

(fun nor ()
    (not (or?.apply rest)))

(fun xor (x y)
    (nor (and? x y) (nor x y)))

(fun append (xs ys)
    (def rv (xs.append ys))
    (if rest
        (append.apply (pair rv rest))
        rv))

(fun apply (f args)
    (f.apply args))

(macro let (name/vars)
    (def is-named (symbol? name/vars))
    (def vars (if is-named rest.head name/vars))
    (fun sep (x y xs names vals)
        (if xs.empty?
            (pair ((pair x names) 'reverse) ((pair y vals) 'reverse))
            (sep xs.head xs.1 xs.tail.tail (pair x names) (pair y vals))))
    (def p
        (if vars.empty?
            (pair '() '())
            (sep vars.head vars.1 vars.tail.tail '() '())))
    (def fn-form (append (list 'fn p.head) (if is-named rest.tail rest)))
    (if is-named
        (seq
            (def args (gensym))
            (list 'let (list args (pair 'list p.tail))
                    (list 'def name/vars fn-form)
                    (list 'apply name/vars args)))
        (pair fn-form p.tail)))

(macro % (head tail) ; pair literal
    (list 'pair (list 'quote head) tail))

(macro : () ; record literal
    (pair 'record
        (if (pair? rest)
            (if (!= (mod rest.size 2) 0)
                (error (list ': "requires an even number of arguments"))
                (let loop (k rest.head v rest.1 xs rest.tail.tail acc '())
                    (def noob (pair (list 'quote k) (pair v acc)))
                    (if (pair? xs)
                        (loop xs.head xs.tail.head xs.tail.tail noob)
                        noob)))
            '())))

(macro cond ()
    (def default
        (if opt.default
            opt.default
            (list 'error (list 'list ''cond-no-matching-clause (list 'pair ''cond (list 'quote rest))))))
    (if (< rest.size 2)
        (error (list 'bad-cond "cond should have at least one predicate and consequent." (pair 'cond rest)))
        (let loop (pred rest.0 conseq rest.1 remaining rest.tail.tail)
            (if remaining
                (list 'if pred conseq (loop remaining.0 remaining.1 remaining.tail.tail))
                (list 'if pred conseq default)))))

(macro qq (expr)
    (fun constant? (expr)
        (if (pair? expr)
            (= expr.head 'quote)
            (not (symbol? expr))))
    (fun combine-skeletons (left right expr)
        (cond
            (and (constant? left) (constant? right))
                (if (and (= (env.eval left)  expr.head)
                         (= (env.eval right) expr.tail))
                    (list 'quote expr)
                    (list 'quote (pair (env.eval left) (env.eval right))))
            (= right '())
                (list 'list left)
            (and (pair? right) (= right.head 'list))
                (pair 'list (pair left right.tail))
            default: (list 'pair left right)))
    (fun expand-quasiquote (expr nesting)
        (cond
            (not (pair? expr))
                (if (constant? expr) expr (list 'quote expr))
            (and (is? expr.head 'unq) (= expr.size 2))
                (if nesting.zero?
                    expr.1
                    (combine-skeletons
                        ''unq
                        (expand-quasiquote expr.tail (- nesting 1))
                        expr))
            (and (is? expr.head 'qq) (= expr.size 2))
                (combine-skeletons
                    ''qq
                    (expand-quasiquote expr.tail (+ nesting 1))
                    expr)
            (if (pair? expr.head)
                (and (= expr.head.head 'unqs) (= expr.head.size 2))
                false)
                (if (= nesting 0)
                    (list 'append
                          expr.head.1
                          (expand-quasiquote expr.tail nesting))
                    (combine-skeletons
                        (expand-quasiquote expr.head (- nesting 1))
                        (expand-quasiquote expr.tail nesting)
                        expr))
            default:
                (combine-skeletons
                    (expand-quasiquote expr.head nesting)
                    (expand-quasiquote expr.tail nesting)
                    expr)))
    (expand-quasiquote expr 0))

(macro when (pred)
    (qq
        (if (unq pred)
            (seq (unqs rest))
            null)))

(macro case (val)
    (def default
        (if opt.default
            opt.default
            (list 'error (list 'list ''case-no-matching-clause (list 'pair ''case (list 'quote rest))))))
    (if (< rest.size 2)
        (error (list 'bad-case "case should have at least one predicate and consequent." (pair 'case rest)))
        (seq
            (def cval (gensym))
            (qq
                (let ((unq cval) (unq val))
                    (unq
                        (let loop (set rest.0 conseq rest.1 remaining rest.tail.tail)
                            (def pred (qq ((send (quote (unq set)) 'has?) (unq cval))))
                            (if remaining
                                (list 'if pred conseq (loop remaining.0 remaining.1 remaining.tail.tail))
                                (list 'if pred conseq default)))))))))

(macro while (pred body)
    ; call (next <value>) to skip the rest of the bodies and go to the next loop (continue)
    ;     if predicate evals false, <value> will be returned from the while expression
    ; call (return <value>) to terminate the loop and return said value (break)
    (def loop (gensym))
    (def rv (gensym))
    (qq
        ((thunk
            (def (unq loop)
                (fn ((unq rv))
                    (macro next (v) (list 'return (list '(unq loop) v)))
                    (macro last (v) (qq (return (unq v))))
                    (if (unq pred)
                        ((unq loop) (seq (unqs (pair body rest))))
                        (unq rv))))
            ((unq loop) null)))))

(macro _ (body)
    (def uscore (gensym))
    (def bodies (pair body rest))
    (fun rename (form)
        (if (pair? form)
            (form.map rename)
            (if (= form '_)
                uscore
                form)))
    (qq
        (fn ((unq uscore))
            (unqs (rename bodies)))))

(macro with-gensyms (gs)
    (qq
        (let (unq (apply append (gs.map (_ (list _ '(gensym))))))
            (unqs rest))))

(fun range (start end)
    (def step (if opt.step opt.step 1))
    (let loop (i start acc '())
        (if (> i end)
            acc.reverse
            (loop (+ i step) (pair i acc)))))

(fun ndx (n x)
    (fun dx ()
        (+ 1 (rand x)))
    (let loop (m n total 0)
        (if m.zero?
            total
            (loop m.dec (+ total (dx))))))

;(macro spec (name pred exec)
;    (def obj (env.lookup name))
;    (def is-local (env.local? name))
;    (if (not (fn? obj))
;        (error "spec is used to specialize functions.")
;        (seq
;            (def fs obj.formals)
;            (def foo (gensym))
;            (def noob
;                `(fn ,fs
;                    (if ((fn ,fs ,pred) ,@fs)
;                        ((fn ,fs ,exec) ,@fs)
;                        (,foo (list ,@fs)))))
;            (if is-local
;                ; This will not work with globals.  Think on it some more.
;                `(seq (def ,foo ,name) (set! ,name ,noob))
;                `(seq (def ,foo ,name) (def ,name ,noob))))))


